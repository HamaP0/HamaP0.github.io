---
layout: post
title: "A04:2021 - Insecure Design (안전하지 않은 설계) 분석 보고서"
date: 2025-08-28 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 4. A04:2021 - Insecure Design (안전하지 않은 설계) 분석 보고서**

### **1. 취약점 개요**

**안전하지 않은 설계**는 단순한 코드 오류와는 근본적으로 다릅니다. 이는 프로그램의 기획 및 설계 단계에서 보안 고려 사항을 간과하여 발생하는 구조적 결함입니다. 예를 들어, '비밀번호를 5회 이상 잘못 입력할 경우 계정을 잠금 처리', 또는 '사용자가 업로드하는 파일의 잠재적인 위험성 검토'와 같은 기본적인 안전 조치를 초기 설계 단계에서 누락하는 경우를 의미합니다.

이번 보고서에서는 DVWA에 있는 무차별 대입 공격, CSRF(Cross-Site Request Forgery), 파일 업로드 취약점을 분석하여, 개발자가 기능 구현 시 어떤 부분을 간과하는지, 그리고 이러한 작은 결함이 얼마나 심각한 위협으로 확대될 수 있는지를 확인하고, 이에 대한 해결 방안을 고민해 보았습니다.


---

#### **2. 시나리오 분석 및 재현**

**Part 1. 무한도전: 로그인 시도 횟수를 고려하지 않은 설계**

*   **가설 설정:**
로그인 기능 설계 시, **로그인 시도 횟수 제한**이나 **계정 잠금 정책**과 같은 방어 규칙이 없다면, 공격자는 자동화된 도구를 이용해 무한히 비밀번호를 추측하여 결국 계정을 탈취할 수 있을 것이다.

*   **공격 검증:**
Burp Suite의 Intruder 툴을 사용하여 로그인 페이지에 대한 무차별 대입 공격을 수행했습니다. 처음에는 모든 요청이 'Status Code 200'으로 반환되어 공격이 실패한 것으로 생각했지만, 서버의 로직 차이로 인해 성공과 실패 시 응답 내용 크기에 미세한 차이가 있을 수 있다는 가설을 세우고 Length 값을 정렬했습니다.

   ![Welcome](/assets/images/A04_P1-1.png)
   ![incorrect](/assets/images/A04_P1-2.png)

정렬된 응답 결과를 자세히 분석한 결과, 흥미로운 패턴을 발견했습니다. 비밀번호가 틀렸을 때 서버가 반환하는 응답의 크기는 대부분 5030 또는 5029였지만, 유일하게 정답인 'password'를 입력했을 때만 응답 크기가 5072로 두드러지게 달랐습니다. 이 차이를 확인하기 위해 두 응답 내용을 비교한 결과, 틀린 비밀번호에 대해서는 "비밀번호가 틀립니다"라는 메시지가, 정답 비밀번호에 대해서는 "환영합니다"라는 메시지가 포함되어 있어 크기 차이가 발생했음을 확인했습니다.

이것은 두 가지 중요한 사실을 알려주었습니다.
첫째, 서버는 공격자가 수많은 비밀번호를 시도하는 동안 어떠한 제재나 경고 조치도 취하지 않았습니다. 이는 로그인 시도 횟수 제한 기능이 설계되지 않은 심각한 보안 취약점임을 의미합니다.
둘째, 정답과 오답에 따른 응답 크기의 차이는 공격자에게 결정적인 힌트를 제공할 수 있습니다.
결론적으로, 로그인 시도 횟수 제한이 없는 설계 결함으로 인해 공격자는 원하는 만큼 비밀번호를 무작위로 시도할 수 있었고, 응답 크기라는 중요한 힌트를 이용하여 최종적으로 실제 비밀번호를 알아낼 수 있었습니다.

   ![주입 자동화](/assets/images/A04_P1-3.png)

*   **위험성 분석:**
이 설계 결함은 사용자의 계정 정보가 탈취되는 직접적인 원인이 됩니다. 공격자는 탈취한 계정으로 다른 사용자의 개인정보를 훔쳐보거나, 관리자 계정일 경우 시스템 전체를 장악할 수 있습니다.

**Part 2. 무조건적인 신뢰: 사용자의 요청을 검증하지 않는 설계**

*   **가설 설정:**
비밀번호 변경 기능이 '브라우저를 통해 들어온 요청은 모두 사용자가 직접 의도한 것'이라고 맹목적으로 신뢰하도록 설계되었다면, 공격자는 악성 페이지를 만들어 사용자가 모르는 사이에 비밀번호를 변경하도록 만들 수 있을 것이다.

*   **공격 검증:**
먼저 공격용 `attack.html` 파일을 제작하고, `python3 -m http.server` 명령어로 간단한 로컬 웹서버를 열었습니다.

   ![attack](/assets/images/A04_P2-1.png)

그런데 이상하게도, 최신 파이어폭스 브라우저로 이 공격 페이지에 접속했는데 예상과 달리 비밀번호가 바뀌지 않았습니다. 원인을 찾아보니 DVWA 페이지 아래쪽에 친절하게 설명이 있었습니다. 바로 최신 브라우저에는 'SameSite=Lax'라는 똑똑한 쿠키 보안 정책이 기본으로 들어 있어서, 다른 사이트에서 보낸 요청에는 인증 쿠키 전송을 제한하기 때문에 고전적인 CSRF 공격이 막힌 것이었습니다.

   ![failed](/assets/images/A04_P2-2.png)
   ![SameSite cookie](/assets/images/A04_P2-3.png)

단순히 취약점을 재현하는 수준을 넘어, 이 분석을 통해 현대 웹 브라우저의 보안 정책이 고전적인 CSRF 공격을 어떻게 효과적으로 차단하는지 직접 확인하고 이해하는 기회를 가질 수 있었습니다.

*   **위험성 분석:**
만약 `SameSite` 정책이 없는 구형 브라우저였다면, 사용자는 자신도 모르는 사이에 계정을 탈취당했을 것입니다. 이는 금전적 피해나 중요 정보 유출로 이어질 수 있는 심각한 설계 결함입다.

**Part 3. 위험한 관대함: 업로드 파일의 내용을 검증하지 않는 설계**

*   **가설 설정:**
파일 업로드 기능이 '사용자는 이미지 파일만 올릴 것'이라는 순진한 가정 하에 설계되었다면, 해커 사진 파일인 척 위장한 악성 스크립트(웹쉘)를 업로드하여 서버를 직접 제어할 수 있을 것이다.

*   **공격 검증:**
서버의 정보를 보여주는 간단한 PHP 코드(phpinfo())가 담긴 shell.php 파일을 만들어서 업로드해봤습니다. 놀랍게도 아무런 검사 없이 바로 업로드에 성공했다는 메시지가 떴습니다.

   ![upload](/assets/images/A04_P3-1.png)

해당 디렉터리(.../DVWA/hackable/uploads/shell.php)에 접근하여 phpinfo() 정보가 출력되는 것을 확인한 결과, 서버가 파일의 종류나 내용 검증 없이 파일을 저장하고, 접근 권한조차 제대로 설정되어 있지 않아 임의의 사용자가 파일에 접근하여 실행할 수 있다는 심각한 보안 문제를 확인했습니다.

   ![phpinfo](/assets/images/A04_P3-2.png)

*   **위험성 분석:**
웹쉘 업로드가 성공했다는 것은 사실상 서버의 열쇠를 해커에게 넘겨준 것과 같습니다. 해커는 이 웹쉘을 통해 데이터베이스 정보를 모두 빼가거나, 서버를 인질로 삼아 돈을 요구하는 랜섬웨어 공격을 하는 등 상상할 수 있는 최악의 공격을 할 수 있게 됩니다.

---

#### **3. 근본 원인 및 해결 방안**

*   **원인: 공격자의 관점으로 생각하지 않은 설계**

위 세 가지 사례의 공통적인 근본 원인은 개발 초기, 즉 설계 단계에서 "만약 누군가 이 기능을 악의적으로 사용한다면?" 이라는 질문을 하지 않았기 때문입다. 로그인, 비밀번호 변경, 파일 업로드 기능 모두 정상적인 사용자의 흐름만을 가정한 채, 공격자가 시도할 수 있는 온갖 이상한 방법들에 대한 방어 계획이 설계도에 아예 빠져 있었던 것입니다.

*   **해결 방안: Shift Left - 코딩 전에 먼저 위협을 모델링하라**

가장 좋은 해결책은 코드를 짜기 시작하기 전, 즉 설계 단계로 돌아가 보안을 먼저 챙기는 Shift Left 접근법을 사용하는 것입니다. 그리고 그 핵심은 바로 위협 모델링(Threat Modeling)입니다.

*   **위협 모델링이란?:** 우리가 만들 기능에 대해 공격자의 입장에서 "어떤 나쁜 일이 일어날 수 있을까?"를 미리 체계적으로 분석하고, 설계의 약점을 찾아내는 과정입다.
*   로그인 기능을 설계할 때 위협 모델링을 했다면, '무차별 대입 공격' 위협을 바로 떠올리고 '로그인 시도 횟수 제한'과 '계정 잠금' 기능을 설계에 반영했을 겁니다.
*   비밀번호 변경 기능을 설계할 때도 'CSRF' 위협을 예측하고, "이 요청이 진짜 사용자가 보낸 게 맞나?"를 확인하는 'Anti-CSRF 토큰' 같은 안전장치를 추가했을 겁니다.
*   파일 업로드 기능 역시 '웹쉘 업로드' 위협을 생각해내고, "업로드 폴더는 절대 실행되지 않도록 막고, 파일 내용도 꼭 검사해야 한다"는 규칙을 설계에 포함했을 겁니다.

이처럼 설계 단계에서 미리 위협을 예측하고 방어 계획을 세웠다면, 제가 위에서 발견했던 모든 문제들은 애초에 만들어지지 않았을 것입니다.


<hr class="short-rule">
