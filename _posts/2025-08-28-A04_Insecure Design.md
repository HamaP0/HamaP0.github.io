---
layout: post
title: "A04:2021 - Insecure Design (안전하지 않은 설계) 분석 보고서"
date: 2025-08-28 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 4. A04:2021 - Insecure Design (안전하지 않은 설계) 분석 보고서

### **1. 취약점 개요**

'안전하지 않은 설계'는 단순히 코드 한 줄을 잘못 짜는 '실수'와는 조금 다른 문제입니다. 이것은 아예 프로그램을 기획하고 설계도를 그리는 첫 단계에서부터 보안을 충분히 고민하지 않았을 때 생기는 구조적인 문제입니다. 예를 들어 "비밀번호를 5번 틀리면 계정을 잠가야지" 또는 "사용자가 올리는 파일이 혹시 위험한 건 아닐까?" 같은 아주 기본적인 안전 규칙들을 처음부터 생각하지 않고 빼먹은 상태를 말합니다.

이번 보고서에서는 DVWA에 있는 세 가지 다른 기능(무차별 대입, CSRF, 파일 업로드)을 살펴보면서, 개발자가 처음 기능을 만들 때 어떤 점을 놓쳤고, 그 작은 빈틈이 얼마나 큰 위협으로 이어질 수 있는지 직접 확인하고 해결책을 고민해 보았습니다.


---

#### **2. 시나리오 분석 및 재현**

**Part 1. 무한도전: 로그인 시도 횟수를 고려하지 않은 설계**

*   **가설 설정:**
로그인 기능 설계 시, '로그인 시도 횟수 제한'이나 '계정 잠금 정책'과 같은 방어 규칙이 없다면, 공격자는 자동화된 도구를 이용해 무한히 비밀번호를 추측하여 결국 계정을 탈취할 수 있을 것이다.

*   **공격 검증:**
Burp Suite의 Intruder 툴을 이용해 로그인 페이지에 무차별 대입 공격을 시도했습니다. 처음에는 모든 요청이 `Status Code 200`으로 반환되어 공격이 실패한 줄 알았지만, 혹시 성공과 실패 시 서버가 처리하는 로직의 차이로 인해 응답 내용물의 크기에 미세한 차이가 생길 수도 있지 않을까? 라는 생각에 Length 값을 정렬해보았습니다.

   ![Welcome](/assets/images/A04_P1-1.png)
   ![incorrect](/assets/images/A04_P1-2.png)

응답 결과를 자세히 뜯어보니 아주 흥미로운 점을 발견했습니다. 비밀번호가 틀렸을 때 서버가 보내주는 응답의 크기(Length)는 대부분 5030 또는 5029였는데, 유일하게 정답인 'password'를 입력했을 때만 응답 크기가 5072로 달랐습니다. 이상해서 두 응답 내용을 비교해 보니, 틀렸을 땐 "비밀번호가 틀립니다" 메시지가, 맞았을 땐 "환영합니다" 메시지가 담겨 있었기 때문에 내용물의 크기가 달랐던 것입니다.

이것은 두 가지 중요한 사실을 알려주었습니다.
첫째, 서버는 제가 수많은 비밀번호를 시도하는 동안 단 한 번도 저를 막거나 경고하지 않았습니다. 이것만으로도 로그인 시도 횟수 제한 기능이 설계되지 않은 심각한 약점이 있다는 것을 알 수 있었습니다.
둘째, 정답일 때와 오답일 때 응답의 크기가 다르다는 결정적인 힌트를 주었습니다.
결국 로그인 시도 횟수 제한이 없는 설계 허점 덕분에 마음껏 비밀번호를 시도해 볼 수 있었고, 응답 크기라는 힌트를 이용해 진짜 비밀번호를 찾아낼 수 있었습니다.

   ![주입 자동화](/assets/images/A04_P1-3.png)

*   **위험성 분석:**
이 설계 결함은 사용자의 계정 정보가 탈취되는 직접적인 원인이 됩니다. 공격자는 탈취한 계정으로 다른 사용자의 개인정보를 훔쳐보거나, 관리자 계정일 경우 시스템 전체를 장악할 수 있습니다.

**Part 2. 무조건적인 신뢰: 사용자의 요청을 검증하지 않는 설계**

*   **가설 설정:**
비밀번호 변경 기능이 '브라우저를 통해 들어온 요청은 모두 사용자가 직접 의도한 것'이라고 맹목적으로 신뢰하도록 설계되었다면, 공격자는 악성 페이지를 만들어 사용자가 모르는 사이에 비밀번호를 변경하도록 만들 수 있을 것이다.

*   **공격 검증:**
먼저 공격용 `attack.html` 파일을 제작하고, `python3 -m http.server` 명령어로 간단한 로컬 웹서버를 열었습니다.

   ![attack](/assets/images/A04_P2-1.png)

그런데 이상하게도, 최신 파이어폭스 브라우저로 이 공격 페이지에 접속했는데 예상과 달리 비밀번호가 바뀌지 않았습니다. 원인을 찾아보니 DVWA 페이지 아래쪽에 친절하게 설명이 있었습니다. 바로 최신 브라우저에는 'SameSite=Lax'라는 똑똑한 쿠키 보안 정책이 기본으로 들어 있어서, 다른 사이트에서 보낸 요청에는 인증 쿠키 전송을 제한하기 때문에 고전적인 CSRF 공격이 막힌 것이었습니다.

   ![failed](/assets/images/A04_P2-2.png)
   ![SameSite cookie](/assets/images/A04_P2-3.png)

이 분석을 통해 단순히 취약점을 재현하는 것을 넘어, 현대 웹 브라우저의 보안 정책이 어떻게 고전적인 CSRF 공격을 막아내는지 직접 확인하는 값진 경험을 할 수 있었습니다.

*   **위험성 분석:**
만약 `SameSite` 정책이 없는 구형 브라우저였다면, 사용자는 자신도 모르는 사이에 계정을 탈취당했을 것입니다. 이는 금전적 피해나 중요 정보 유출로 이어질 수 있는 심각한 설계 결함입다.

**Part 3. 위험한 관대함: 업로드 파일의 내용을 검증하지 않는 설계**

*   **가설 설정:**
파일 업로드 기능이 '사용자는 이미지 파일만 올릴 것'이라는 순진한 가정 하에 설계되었다면, 해커 사진 파일인 척 위장한 악성 스크립트(웹쉘)를 업로드하여 서버를 직접 제어할 수 있을 것이다.

*   **공격 검증:**
서버의 정보를 보여주는 간단한 PHP 코드(phpinfo())가 담긴 shell.php 파일을 만들어서 업로드해봤습니다. 놀랍게도 아무런 검사 없이 바로 업로드에 성공했다는 메시지가 떴습니다.

   ![upload](/assets/images/A04_P3-1.png)

처음에는 서버가 알려준 상대 경로로 접근 시 'Not Found' 오류가 발생했지만, URL 경로에 `/DVWA/` 디렉토리를 추가(`.../DVWA/hackable/uploads/shell.php`)하여 정확한 경로를 찾아내자 성공적으로 `phpinfo()` 정보가 출력되는 것을 확인했습니다. 이것은 서버가 파일의 종류나 내용을 전혀 확인하지 않고, 심지어 누구나 접근해서 실행할 수 있는 위험한 곳에 파일을 저장하도록 설계되었다는 확실한 증거였습니다.

   ![phpinfo](/assets/images/A04_P3-2.png)

*   **위험성 분석:**
웹쉘 업로드가 성공했다는 것은 사실상 서버의 열쇠를 해커에게 넘겨준 것과 같습니다. 해커는 이 웹쉘을 통해 데이터베이스 정보를 모두 빼가거나, 서버를 인질로 삼아 돈을 요구하는 랜섬웨어 공격을 하는 등 상상할 수 있는 최악의 공격을 할 수 있게 됩니다.

---

#### **3. 근본 원인 및 해결 방안**

*   **원인: 공격자의 관점으로 생각하지 않은 설계**

위 세 가지 사례의 공통적인 근본 원인은 개발 초기, 즉 설계 단계에서 "만약 누군가 이 기능을 악의적으로 사용한다면?" 이라는 질문을 하지 않았기 때문입다. 로그인, 비밀번호 변경, 파일 업로드 기능 모두 정상적인 사용자의 흐름만을 가정한 채, 공격자가 시도할 수 있는 온갖 이상한 방법들에 대한 방어 계획이 설계도에 아예 빠져 있었던 것입니다.

*   **해결 방안: Shift Left - 코딩 전에 먼저 위협을 모델링하라**

가장 좋은 해결책은 코드를 짜기 시작하기 전, 즉 설계 단계로 돌아가 보안을 먼저 챙기는 Shift Left 접근법을 사용하는 것입니다. 그리고 그 핵심은 바로 위협 모델링(Threat Modeling)입니다.

*   **위협 모델링이란?:** 우리가 만들 기능에 대해 공격자의 입장에서 "어떤 나쁜 일이 일어날 수 있을까?"를 미리 체계적으로 분석하고, 설계의 약점을 찾아내는 과정입다.
*   로그인 기능을 설계할 때 위협 모델링을 했다면, '무차별 대입 공격' 위협을 바로 떠올리고 '로그인 시도 횟수 제한'과 '계정 잠금' 기능을 설계에 반영했을 겁니다.
*   비밀번호 변경 기능을 설계할 때도 'CSRF' 위협을 예측하고, "이 요청이 진짜 사용자가 보낸 게 맞나?"를 확인하는 'Anti-CSRF 토큰' 같은 안전장치를 추가했을 겁니다.
*   파일 업로드 기능 역시 '웹쉘 업로드' 위협을 생각해내고, "업로드 폴더는 절대 실행되지 않도록 막고, 파일 내용도 꼭 검사해야 한다"는 규칙을 설계에 포함했을 겁니다.

이처럼 설계 단계에서 미리 위협을 예측하고 방어 계획을 세웠다면, 제가 위에서 발견했던 모든 문제들은 애초에 만들어지지 않았을 것입니다.

<hr class="short-rule">