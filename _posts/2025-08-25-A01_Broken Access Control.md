---
layout: post
title: "A01:2021 - Broken Access Control (접근 통제 실패) 분석 보고서"
date: 2025-08-25 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 1. A01:2021 - Broken Access Control (접근 통제 실패) 분석 보고서**

### 1. 취약점 개요

   접근 통제 실패는 '모든 문에 맞는 만능 열쇠'를 공격자에게 쥐어주는 것과 같습니다. 이는 시스템이 사용자의 요청에 대해 '정말로 이 작업을 수행할 권한이 있는가?'를 매번 확인하지 않을 때 발생하는 모든 보안 허점을 의미합니다. 결과적으로 단순 정보 유출에서 시작하여 다른 사용자 계정을 탈취하고 최종적으로는 서버의 모든 권한을 장악당하는 가장 직접적이고 치명적인 위협으로 이어집니다.

   본 보고서는 경로 조작이라는 작은 균열을 시작으로 단계적으로 권한을 상승시켜 시스템 전체를 장악해나가는 실제적인 공격 시나리오를 증명합니다.

---

### 2. 시나리오 분석 및 재현
#### Part 1. [정보 수집] 경로 조작`Path Traversal`으로 시스템 사용자 목록 탈취하기

*   **공격 시나리오:**
   웹 애플리케이션이 URL 파라미터를 통해 서버 내부의 파일 이름을 직접 전달받는 경우, 서버가 요청한 사용자가 해당 파일에 접근할 권한이 있는지 개별적으로 확인하지 않는다면, 공격자는 경로를 조작하여 허가되지 않은 시스템 파일에 접근할 수 있을 것이다.

*   **공격 검증:**
   page 파라미터에 상위 디렉토리로 이동하는 `../` 문자를 반복적으로 삽입하는 경로 조작(Path Traversal) 공격을 시도했습니다. `../../../../../../etc/passwd` 페이로드를 통해 웹 애플리케이션의 경계를 벗어나 리눅스 시스템의 핵심 파일인 `/etc/passwd`에 접근을 요청하자, 서버는 권한 검사를 완전히 생략하고 시스템의 모든 사용자 계정 목록을 그대로 노출했습니다.

   ![]({{ "/assets/images/A01_P1-1.png" | relative_url }})

   이 취약점의 근본 원인은 아래 소스코드와 같이, 사용자 입력값`$_GET['page']`을 아무런 검증이나 필터링 없이 신뢰하고 파일 경로로 사용했기 때문입니다.

   ![]({{ "/assets/images/A01_P1-2.png" | relative_url }})

*   **위험성 분석:**
   이는 시스템의 내부 구조와 설정, 사용자 목록 등 2차 공격에 필요한 핵심 정보를 수집하는 첫 단계입니다. 이 정보가 없었다면 다음 단계의 공격은 훨씬 더 어려웠을 것입니다.

>   이 `/etc/passwd` 파일에서 확보한 시스템 계정 목록은, 우리가 단순 방문객이 아닌 내부 구조를 아는 공격자임을 증명하는 첫 번째 트로피이자 다음 공격의 발판이었습니다.

#### Part 2. [권한 상승] 강제 브라우징`Forced Browsing`으로 관리자 기능 접근하기

*   **공격 시나리오:**
   관리자 전용 페이지가 단순히 메뉴 링크를 숨기는 방식으로만 보호되고, 서버 측에서 각 요청에 대한 실질적인 권한 검사를 수행하지 않는다면, 공격자는 페이지의 URL을 직접 추측하여 입력하는 강제 브라우징`Forced Browsing` 기법만으로 관리자 기능에 무단으로 접근할 수 있을 것이다.

*   **공격 검증:**
   Part 1에서 시스템이 허술하다는 단서를 얻은 후, 일반 사용자 권한으로 로그인된 세션을 유지한 채 관리자 기능으로 예상되는 `/DVWA/setup.php` URL로 직접 접근을 시도했습니다. 서버는 이 요청을 보낸 사용자가 관리자인지 확인하는 핵심적인 권한 검사 로직을 누락했고, 그 결과 모든 사용자의 정보를 관리할 수 있는 페이지를 일반 사용자에게 그대로 허용했습니다.

   ![]({{ "/assets/images/A03_P2-1.png" | relative_url }})

*   **위험성 분석:**
   이 단계에서 공격자는 단순히 정보를 보는 것을 넘어 시스템의 기능을 직접 제어할 수 있게 됩니다. 관리자 페이지 확보는 다음 단계인 서버 운영체제 장악을 위한 교두보를 마련했음을 의미합니다.

#### Part 3. [시스템 장악] 명령어 인젝션`RCE`으로 서버 제어권 획득하기

*   **공격 시나리오:**
   지금까지 확보한 시스템 정보와 관리 기능 접근 권한을 바탕으로, 서버의 입력값 검증 로직이 불완전할 것이라 가정하고, 이를 우회하는 고도화된 페이로드를 주입하여 웹 애플리케이션의 경계를 넘어 서버 운영체제 자체를 제어할 수 있을 것이다.

*   **공격 검증:**
   Command Injection 기능의 특수문자 필터링을 우회하기 위해, 공격자 서버로 리버스 쉘 `Reverse Shell` 을 연결하는 bash 명령어를 Base64로 인코딩하여 필터링을 우회했습니다. 공격자 PC에서 연결을 대기시킨 후, 인코딩된 페이로드를 서버에 주입하자 성공적으로 `www-data` 사용자의 쉘(Shell)을 획득하여 서버를 직접 제어할 수 있게 되었습니다.

   ![]({{ "/assets/images/A01_P3-1.png" | relative_url }})

   공격자 PC에서 netcat으로 연결을 대기시킨 후, 인코딩된 페이로드를 서버에 주입하자 성공적으로 서버의 쉘Shell을 획득했습니다. 이는 `www-data` 사용자의 권한으로 서버를 직접 제어할 수 있게 되었음을 의미합니다.

   ![]({{ "/assets/images/A01_P3-2.png" | relative_url }})

   획득한 쉘에서 `cat /etc/passwd` 명령을 실행하여, Part 1에서 웹을 통해 간접적으로 보았던 정보를 이제 서버 내부에서 직접 조회함으로써 시스템에 대한 완전한 통제권을 확보했음을 명백히 증명했습니다.

   ![]({{ "/assets/images/A01_P3-3.png" | relative_url }})

*   **위험성 분석:**
   이것은 접근 통제 실패의 최종 단계입니다. 공격자는 더 이상 웹의 제약을 받지 않으며, 서버를 거점으로 내부망을 공격하거나, 랜섬웨어를 배포하고, 모든 데이터를 파괴 또는 유출하는 등 상상할 수 있는 모든 악의적 행위가 가능해졌습니다.

>   지금까지의 공격은 전통적인 웹 페이지를 대상으로 했습니다. 하지만 현대 웹/앱 환경의 핵심은 API입니다. 마지막으로 이 접근 통제 실패 문제가 API 환경에서 어떻게 나타나는지 분석합니다.

#### Part 4. [공격 확장] API의 허점`IDOR`을 이용해 타 사용자 정보 접근하기

*   **공격 시나리오:**
   만약 사용자 정보 조회 API 엔드포인트가 요청된 자원Object의 ID 값에 대한 소유권을 검증하지 않는다면, 공격자는 자신의 ID를 다른 사용자의 ID로 변경하는 간단한 조작만으로 허가되지 않은 타인의 정보에 직접 접근 `IDOR`할 수 있을 것이다.

*   **공격 검증:**
   DVWA에는 해당 기능이 없으므로, Burp Suite의 Repeater 기능을 이용해 가상의 사용자 정보 조회 API`GET /api/v1/users/{userID}`가 존재한다고 가정하고 공격을 시뮬레이션했습니다. 먼저, 인증된 세션 쿠키를 이용해 자신의 사용자 정보`userID=1`를 요청하는 정상적인 API 요청을 생성했습니다.

   ![자신의 정보를 요청하는 가상 API](/assets/images/A01_P4-1.png)

   그 다음, 이 요청에서 userID 값만 다른 사용자의 ID`userID=2`로 변경하여 재전송했습니다. 아래 화면은 다른 사용자의 리소스를 요청하는 **IDOR**Insecure Direct Object References 공격 시도를 보여줍니다. 만약 서버 측에서 요청을 보낸 세션의 주인과 요청된 userID가 일치하는지 검증하는 로직이 없다면, 이 요청은 성공하여 다른 사용자의 민감한 개인정보를 유출시킬 것입니다.

   ![다른 사용자의 정보를 요청하는 IDOR 공격](/assets/images/A01_P4-2.png)

*   **위험성 분석:**
   API는 오늘날 모바일 앱과 SPA(Single Page Application)의 데이터 교환을 책임지는 핵심 통로입니다. API 레벨에서의 접근 통제 실패는 웹 페이지를 넘어 애플리케이션의 가장 민감한 데이터가 대량으로 유출되는 직접적인 원인이 됩니다. 이는 단순 정보 유출을 넘어 기업의 신뢰도와 비즈니스에 치명적인 타격을 줄 수 있습니다.

---

### 3. 원인 및 해결 방안

*   **원인: 신뢰해서는 안 될 것을 신뢰한 설계**

   이 4단계의 연쇄적인 붕괴는 단 하나의 근본 원인, 즉 '사용자로부터 온 것은 그 어떤 것도 신뢰할 수 없다' 는 보안의 제1원칙을 지키지 않았기 때문입니다. 개발자는 URL 파라미터 · 페이지 요청 · API의 ID 값 등 공격자가 제어할 수 있는 모든 입력값을 맹목적으로 신뢰했습니다. 이는 시스템의 모든 경계에서 문을 열어준 것과 같은 설계상의 치명적인 오류입니다.

*   **해결 방안: 제로 트러스트 기반의 다층적 방어 전략**

   안전한 접근 통제는 단 하나의 기술로 해결되지 않습니다. 코드, 아키텍처 정책에 걸친 다층적 방어Defense in Depth를 구현해야 합니다.

1.  **[코드 레벨 방안] 서버 측 세션 기반 검증:**
   가장 기본적이고 강력한 처방은 사용자가 전달한 ID나 파라미터를 기준으로 권한을 판단하지 않는 것입니다. 대신 **서버에 안전하게 저장된 세션 정보**를 기준으로 '현재 로그인한 사용자가 누구인지'를 식별하고 그 사용자의 권한에 맞는 작업만 허용해야 합니다.

2.  **[아키텍처 레벨 방안] 중앙 집중식 권한 검증:**
   모든 요청(Web · API 등)은 비즈니스 로직에 도달하기 전 API 게이트웨이나 공통 미들웨어 같은 **중앙 집중화된 단일 지점`Single Point of Validation`**을 반드시 통과해야 합니다. 이 지점에서 '현재 사용자가 요청된 자원에 대해 허가된 행위를 수행할 권한이 있는가?'를 일관되게 검증하여 모든 경계에서 동일한 보안 정책을 강제해야 합니다.

3.  **[정책 레벨 방안] 기본 거부 원칙 Default Deny:**
   모든 접근은 기본적으로 '거부' 상태에서 시작해야 합니다. 그리고 명시적으로 허용된 특정 역할과 조건에 대해서만 접근을 '허용'해야 합니다. 이는 화이트리스트 방식의 정책 설계이며 예상치 못한 접근 경로를 원천적으로 차단합니다.

---

### 4. 시큐어 코딩: 코드 레벨 분석

**분석 대상:** DVWA - File Inclusion

#### 취약한 코드 분석 Low Level

   ![]({{ "/assets/images/A01_S-1.png" | relative_url }})

   *   **코드 분석:** 위 코드는 **`$_GET['page']`** 를 통해 사용자로부터 입력받은 파일 경로를 아무런 검증 없이 **`$file`** 변수에 할당하고 이를 그대로 **`include`** 함수에 전달하고 있습니다. 이는 공격자가 `../` 와 같은 경로 조작 페이로드로 서버의 모든 파일을 읽을 수 있도록 허용하는 전형적인 경로 조작Path Traversal 취약점입니다.

#### 안전한 코드 분석 Impossible Level

   ![]({{ "/assets/images/A01_S-2.png" | relative_url }})  

   *   **코드 분석:** 안전한 코드는 사용자 입력값을 절대 신뢰하지 않습니다. **`$_GET['page']`** 로 받은 입력값을 직접 파일 경로로 사용하는 대신 `if` 와 `else if` 문을 통해 서버에 미리 정의된 **안전한 파일 목록** 'include.php', 'file1.php' 과 정확히 일치하는지 먼저 확인합니다. 이 '화이트리스트' 목록에 없는 어떠한 입력값도 허용하지 않으므로 경로 조작 공격은 원천적으로 불가능합니다.

#### 핵심 방어 원리

   결론적으로 접근 통제 실패의 핵심 방어 원리는 '사용자 제어 가능 입력 User-Controllable Input을 권한 판단의 기준으로 삼지 않는 것' 입니다. 권한 검증은 반드시 서버 측의 신뢰할 수 있는 데이터(세션, DB)를 기반으로 이루어져야 합니다.

<hr class="short-rule">