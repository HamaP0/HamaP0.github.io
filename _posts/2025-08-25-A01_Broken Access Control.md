---
layout: post
title: "A01:2021 - Broken Access Control (접근 통제 실패) 분석 보고서"
date: 2025-08-25 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 1. A01:2021 - Broken Access Control (접근 통제 실패) 분석 보고서**

### **1. 취약점 개요**

**접근 통제**는 웹 보안에서 '누가 무엇을 할 수 있는가?'라는 기본적인 질문에 대한 답을 제공하는 규칙 시스템입니다. 이는 일반 사용자는 자신의 게시글만 수정 가능하고, 관리자는 모든 기능을 수행할 수 있는 것과 같이, 역할에 따른 권한 범위를 설정하고 이를 강제하는 것을 의미합니다. **접근 통제 실패**는 이러한 권한 범위가 무너져 사용자가 허용되지 않은 정보에 접근하거나(수평적 침해), 자신의 권한을 넘어서는 기능(수직적 권한 상승)을 실행할 수 있게 되는 모든 문제를 포함합니다.

본 보고서에서는 접근 통제 실패가 어떻게 작은 정보 유출에서 시작하여 시스템 전체를 장악하는 심각한 위협으로 확대되는지, 그리고 파일 시스템, 페이지 접근, 명령어 실행을 넘어 현대 웹의 핵심인 API까지 포함하는 4단계 공격 시나리오를 통해 상세히 분석합니다.

---

### **2. 시나리오 분석 및 재현**

**Part 1. 수평적 권한 침해: 잠기지 않은 자료실의 민감 정보 유출**

*   **가설 설정:**
웹 애플리케이션이 URL 파라미터를 통해 서버 내부의 파일 이름을 직접 전달받는 경우, 서버가 요청한 사용자가 해당 파일에 접근할 권한이 있는지 개별적으로 확인하지 않는다면, 공격자는 경로를 조작하여 허가되지 않은 시스템 파일에 접근할 수 있을 것이다.

*   **공격 검증:**
'page' 파라미터에 상위 디렉토리로 이동하는 '../' 문자를 반복적으로 삽입하는 경로 조작(Path Traversal) 공격을 시도했습니다. '../../../../../../etc/passwd' 페이로드를 통해 웹 애플리케이션의 경계를 벗어나 리눅스 시스템의 핵심 파일인 '/etc/passwd'에 접근을 요청하자, 서버는 권한 검사를 완전히 생략하고 시스템의 모든 사용자 계정 목록을 그대로 노출했습니다.

   ![]({{ "/assets/images/A01_P1-1.png" | relative_url }})

이 취약점의 근본 원인은 아래 소스코드와 같이, 사용자 입력값(`$_GET['page']`)을 아무런 검증이나 필터링 없이 신뢰하고 파일 경로로 사용했기 때문입니다.

   ![]({{ "/assets/images/A01_P1-2.png" | relative_url }})

*   **위험성 분석:**
이는 시스템의 내부 구조와 설정, 사용자 목록 등 2차 공격에 필요한 핵심 정보를 수집하는 첫 단계입니다. 이 정보가 없었다면 다음 단계의 공격은 훨씬 더 어려웠을 것입니다.

**Part 2. 수직적 권한 상승: 관리자 행세로 기능 장악**

*   **가설 설정:**
관리자 전용 페이지가 단순히 메뉴 링크를 숨기는 방식으로만 보호되고, 서버 측에서 각 요청에 대한 실질적인 권한 검사를 수행하지 않는다면, 공격자는 페이지의 URL을 직접 추측하여 입력하는 **강제 브라우징(Forced Browsing)** 기법만으로 관리자 기능에 무단으로 접근할 수 있을 것이다.

*   **공격 검증:**
Part 1에서 시스템이 허술하다는 단서를 얻은 후, 일반 사용자 권한으로 로그인된 세션을 유지한 채 관리자 기능으로 예상되는 **/DVWA/setup.php** URL로 직접 접근을 시도했습니다. 서버는 이 요청을 보낸 사용자가 관리자인지 확인하는 핵심적인 권한 검사 로직을 누락했고, 그 결과 모든 사용자의 정보를 관리할 수 있는 페이지를 일반 사용자에게 그대로 허용했습니다.

   ![]({{ "/assets/images/A03_P2-1.png" | relative_url }})

*   **위험성 분석:**
이 단계에서 공격자는 단순히 정보를 보는 것을 넘어 시스템의 기능을 직접 제어할 수 있게 됩니다. 다른 사용자의 비밀번호를 변경하거나 관리자 계정을 생성하는 등, 다음 단계인 시스템 완전 장악을 위한 교두보를 마련할 수 있습니다.

**Part 3. 경계를 넘어선 시스템 장악: RCE를 통한 서버 제어권 탈취**

*   **가설 설정:**
지금까지 확보한 시스템 정보와 관리 기능 접근 권한을 바탕으로, 서버의 입력값 검증 로직이 불완전할 것이라 가정하고, 이를 우회하는 고도화된 페이로드를 주입하여 웹 애플리케이션의 경계를 넘어 서버 운영체제 자체를 제어할 수 있을 것이다.

*   **공격 검증:**
**Command Injection** 기능에서 특수문자 필터링으로 인해 일반적인 공격이 막히는 상황을 마주했습니다. 이 방어 로직을 우회하기 위해, 공격자 서버로 역연결(Reverse Shell)을 시도하는 'bash' 명령어를 'base64'로 인코딩하여 웹 방화벽이나 필터가 인식할 수 없는 순수한 문자열 형태로 바꾸는 창의적인 우회 기법을 사용했습니다.

   ![]({{ "/assets/images/A01_P3-1.png" | relative_url }})

공격자 PC에서 'netcat'으로 연결을 대기시킨 후, 인코딩된 페이로드를 서버에 주입하자 성공적으로 서버의 쉘(Shell)을 획득했습니다. 이는 'www-data' 사용자의 권한으로 서버를 직접 제어할 수 있게 되었음을 의미합니다.

   ![]({{ "/assets/images/A01_P3-2.png" | relative_url }})

획득한 쉘의 제어권을 증명하기 위해 `cat /etc/passwd` 명령을 실행했습니다. Part 1에서 웹을 통해 간접적으로 보았던 정보를 이제 서버 내부에서 직접 조회함으로써, 시스템에 대한 완전한 통제권을 확보했음을 명백히 증명했습니다.

   ![]({{ "/assets/images/A01_P3-3.png" | relative_url }})

*   **위험성 분석:**
이것은 접근 통제 실패의 최종 단계입니다. 공격자는 더 이상 웹의 제약을 받지 않으며, 서버를 거점으로 내부망을 공격하거나, 랜섬웨어를 배포하고, 모든 데이터를 파괴하거나 유출하는 등 상상할 수 있는 모든 악의적 행위가 가능해집니다.

**Part 4. 현대적 공격 표면: API 기반 수평적 권한 침해 (IDOR)**

*   **가설 설정:**
현대 웹/앱의 핵심 통신 수단인 API 엔드포인트가 만약 요청된 자원의 ID 값에 대한 소유권을 검증하지 않는다면, 공격자는 자신의 ID를 다른 사용자의 ID로 변경하는 간단한 조작만으로 허가되지 않은 타인의 정보에 직접 접근할 수 있을 것이다.

*   **공격 검증:**
DVWA에는 해당 기능이 없으므로, Burp Suite의 Repeater 기능을 이용해 가상의 사용자 정보 조회 API(`GET /api/v1/users/{userID}`)가 존재한다고 가정하고 공격을 시뮬레이션했습니다. 먼저, 인증된 세션 쿠키를 이용해 자신의 사용자 정보(`userID=1`)를 요청하는 정상적인 API 요청을 생성했습니다.

   ![자신의 정보를 요청하는 가상 API](/assets/images/A01_P4-1.png)

   그 다음, 이 요청에서 userID 값만 다른 사용자의 ID(`userID=2`)로 변경하여 재전송했습니다. 아래 화면은 다른 사용자의 리소스를 요청하는 IDOR(Insecure Direct Object References) 공격 시도를 보여줍니다. 만약 서버 측에서 **요청을 보낸 세션의 주인**과 **요청된 userID**가 일치하는지 검증하는 로직이 없다면, 이 요청은 성공하여 다른 사용자의 민감한 개인정보를 유출시킬 것입니다.

   ![다른 사용자의 정보를 요청하는 IDOR 공격](/assets/images/A01_P4-2.png)

*   **위험성 분석:**
API는 오늘날 모바일 앱과 SPA(Single Page Application)의 데이터 교환을 책임지는 핵심 통로입니다. API 레벨에서의 접근 통제 실패는 웹 페이지를 넘어 애플리케이션의 가장 민감한 데이터가 대량으로 유출되는 직접적인 원인이 됩니다. 이는 단순 정보 유출을 넘어 기업의 신뢰도와 비즈니스에 치명적인 타격을 줄 수 있습니다.

---

#### **3. 근본 원인 및 해결 방안**

*   **원인: 경계에서의 신뢰 기반 설계**

 이 4단계의 연쇄적인 붕괴는 단 하나의 근본 원인, 즉 '사용자로부터 온 것은 그 어떤 것도 신뢰할 수 없다'는 제로 트러스트 원칙을 모든 경계에서 지키지 않았기 때문입니다. URL 파라미터, 페이지 요청, API의 ID 값, 사용자 입력 데이터 등 모든 것을 신뢰한 것이 문제의 시작이었습니다.

*   **해결 방안: 제로 트러스트 기반의 중앙 집중식 권한 검증**

 안전한 접근 통제는 아키텍처 수준에서 구현되어야 합니다. 모든 요청은 비즈니스 로직에 도달하기 전, API 게이트웨이나 공통 미들웨어 같은 중앙 집중화된 단일 지점을 반드시 통과해야 합니다. 이 지점에서 '현재 사용자가 요청된 자원에 대해 허가된 행위를 수행할 권한이 있는가?'를 일관되게 검증하여 모든 경계에서 일관된 보안 정책을 강제해야 합니다.


<hr class="short-rule">

