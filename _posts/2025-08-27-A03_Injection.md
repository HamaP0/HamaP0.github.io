---
layout: post
title: "A03:2021 - Injection (인젝션) 분석 보고서"
date: 2025-08-27 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 3. A03:2021 - Injection (인젝션) 분석 보고서**

#### **1. 취약점 개요**

'인젝션(Injection, 주입)'은 해킹 공격의 가장 대표적인 유형 중 하나입니다. 원래는 사용자가 입력한 값을 '데이터'로만 다뤄야 하는데, 이 규칙이 무너지면서 사용자가 입력한 내용이 갑자기 '쿼리문'이나 '명령어'로 변신해 시스템을 공격하는 모든 문제를 말합니다. 그중에서도 데이터베이스를 직접 공격하는 SQL Injection은 시스템에 가장 치명적인 피해를 줄 수 있는 대표적인 공격 기법입니다.

이 보고서에서 DVWA 환경에서 점진적으로 심화되는 세 가지 SQL Injection 공격 기법(Error-Based, Union-Based, Blind)을 성공시키고, 자동화 도구를 활용하여 그 효율성을 극대화한 후, 시큐어 코딩을 통해 근본적인 해결 방안은 무엇일지 고민해 보았습니다.

---

#### **2. 시나리오 분석 및 재현**

**Part 1. 첫 번째 단서: 서버의 비정상적인 '침묵' (Error-Based via Inference)**

*   **가설 설정:**
사용자 ID를 입력하는 칸에 일반적인 아이디가 아니라, SQL 문법에서 특별한 의미를 갖는 기호(')를 넣으면 서버가 제대로 처리하지 못하고 뭔가 이상한 반응을 보일 것이다.

*   **공격 검증:**
User ID 입력 칸에 작은따옴표(') 하나만 딸랑 입력하고 전송 버튼을 눌렀습니다. 그러자 화면에는 아무것도 나오지 않는 '백지' 페이지만 떴습니다.

하지만 Burp Suite로 서버가 보낸 응답을 자세히 들여다보니, 정상적인 페이지와는 다르게 Content-Length가 0으로 표시되는 것을 발견했습니다. 겉으로는 조용했지만, 서버 내부에서는 제가 보낸 작은따옴표 때문에 에러가 나서 아무런 내용도 만들어내지 못하고 빈 종이를 보낸 셈이죠. 이 '비정상적인 침묵'을 통해, 이 입력 칸이 SQL Injection 공격에 약점이 있다는 강력한 첫 단서를 잡을 수 있었습니다.

   ![Content-Length](/assets/images/A03_P1-2.png)
   ![백지 화면](/assets/images/A03_P1-1.png)

**Part 2. 정보의 홍수: UNION을 이용한 데이터베이스 탈취**

*   **가설 설정:**
약점을 찾았으니, 이제 UNION이라는 SQL 명령어를 주입해서 원래 웹사이트가 보여주려던 정보 뒤에, 우리가 원하는 DB 안의 다른 정보(예: 전체 회원 목록)를 몰래 붙여서 한 번에 빼낼 수 있을 것이다.

*   **공격 검증:**
UNION 공격을 하려면 먼저 원래 화면에 표시되는 정보가 몇 개의 '칸'으로 이루어져 있는지 알아내야 했습니다. ORDER BY라는 명령어로 칸의 개수를 추측해 봤습니다. ORDER BY 2#를 넣었을 땐 정상 화면이 나왔는데, ORDER BY 3#을 넣자 아까처럼 '백지' 화면이 떴습니다.

이 반응의 차이를 보고 이 페이지에서 정보를 보여주는 칸이 2개라고 확신할 수 있었습니다. 이제 칸 개수를 알았으니, 그 2개의 칸에 users 테이블의 user(아이디)와 password(비밀번호)를 채워달라는 UNION SELECT 공격 코드를 주입했습니다. 결과는 놀라웠습니다. 단 한 번의 공격으로 데이터베이스에 저장된 모든 사용자의 아이디와 암호화된 비밀번호를 전부 빼낼 수 있었습니다.

   ![사용자 정보 탈취](/assets/images/A03_P2-1.png)
   ![백지 화면](/assets/images/A03_P2-2.png)
   ![Content-Length](/assets/images/A03_P2-3.png)

*   **위험성 분석:**
이 공격은 대규모 개인정보 유출 사고와 바로 연결됩니다. 탈취된 계정 정보는 2차, 3차 공격에 악용될 수 있으며, 기업의 신뢰도에 치명적인 타격을 입힐 수 있습니다.

**Part 3. 침묵 속의 대화: 반응의 차이로 정보 빼내기 (Blind)**

*   **가설 설정:**
만약 서버가 에러 메시지도 보여주지 않고, UNION 공격 결과도 화면에 나타나지 않는 Blind 상태에서도 SQL 질문이 '참'일 때와 '거짓'일 때 서버가 아주 미세하게 다르게 반응하는 점을 이용한다면 정보를 한 글자씩 대입해 알아낼 수 있을 것이다.

*   **공격 검증:**
 `SQL Injection (Blind)` 메뉴에서, 데이터베이스 버전의 첫 글자가 '8'인지 묻는 참/거짓 질문을 던졌습다.
  *   **거짓(False) 조건:** `1' AND SUBSTRING(VERSION(), 1, 1) = '1'#` 입력하니, "User ID is MISSING..." (사용자가 없습니다) 라는 '거짓'을 의미하는 답변이 돌아왔습니다.
 *   **참(True) 조건:** `1' AND SUBSTRING(VERSION(), 1, 1) = '8'#` 입력하니, "User ID is EXISTS..." (사용자가 존재합니다) 라는 '참'을 의미하는 답변이 돌아왔습니다.

이 두 가지 다른 답변을 통해, 눈에 보이지는 않지만 데이터베이스의 버전이 MySQL 8.x 버전이라는 사실을 정확하게 알아낼 수 있었습니다.

   ![거짓](/assets/images/A03_P3-1.png)
   ![참](/assets/images/A03_P3-2.png)

**Part 4. 실무자의 무기: 자동화 도구의 활용 (`sqlmap`)**

*   **가설 설정:**
 수동 분석으로 원리를 이해했다면, 자동화 도구를 활용하여 Blind SQL Injection처럼 시간이 오래 걸리는 작업을 효율적으로 수행할 수 있을 것이다.

*   **공격 검증:**
직접 찾은 공격 포인트와 제 로그인 정보를 sqlmap이라는 전문 도구에 알려주고 실행시켰습니다. 그러자 사람이 했다면 몇 시간이 걸렸을지도 모를 작업을 단 몇십 초 만에 끝내고, dvwa 데이터베이스의 users 테이블에 있는 모든 정보를 깔끔하게 가져오는 것을 볼 수 있었습니다.
    
   ![sqlmap](/assets/images/A03_P4-1.png)
   ![users table](/assets/images/A03_P4-3.png)

특히 sqlmap은 암호화된 비밀번호 중 풀기 쉬운 것들은 직접 해독까지 해서 원래 비밀번호(password, letmein 등)를 찾아주는 놀라운 기능도 보여주었습니다.

   ![cracked password](/assets/images/A03_P4-2.png)

*   **분석 결론:**
직접 공격을 해보며 취약점의 원리를 깊게 파고드는 능력, 그리고 자동화 도구를 잘 활용해서 지루하고 반복적인 작업을 효율적으로 처리하는 능력. 이 두 가지 모두 보안 전문가가 되기 위해 꼭 필요하다는 것을 깨달았습니다.

---

#### **3. 근본 원인 및 해결 방안**

*   **원인: 데이터와 명령어의 경계 붕괴**

모든 SQL Injection 공격의 진짜 원인은 사용자가 입력한 '데이터'와 개발자가 만든 '명령어'를 서버가 구분하지 못했기 때문입니다. 사용자가 입력한 값을 아무런 의심 없이 원래의 SQL 코드에 그대로 합쳐버리니, 평범한 '데이터'여야 할 입력값이 악의적인 '명령어'로 변신해서 실행되어 버리는 것입니다.

*   **해결 방안: Prepared Statement (매개변수화된 쿼리)**

이 문제를 해결하는 가장 확실하고 안전한 방법은 Prepared Statement(준비된 구문)를 사용하는 것입니다. 실제로 DVWA의 보안 최고 레벨('high') 소스코드에서도 이 방법을 사용하고 있었습니다.

   ![소스코드](/assets/images/A03_Sourcecode.png)

 이 방식의 핵심 원리는 다음과 같다.
 1.  Prepare (준비): 먼저 SQL 코드의 '틀'을 만듭니다. 사용자 입력이 들어갈 자리는 ?로 비워둡니다. (예: SELECT * FROM users WHERE user_id = ?;) 이 양식을 먼저 데이터베이스에 보내서 "이런 형식의 명령을 내릴 거야"라고 알려줍니다.
 2.  Bind & Execute (결합 및 실행): 그 후에 사용자가 입력한 값을 따로 데이터베이스에 보냅니다. 데이터베이스는 이미 받아둔 '틀'의 ? 자리에 입력값을 '데이터'로만 안전하게 채워 넣어 쿼리를 실행합니다.

이렇게 명령어(틀)와 데이터(내용)를 완전히 분리해서 처리하기 때문에, 공격자가 입력값에 UNION 이나 ' 같은 공격 코드를 섞어 보내더라도 절대 명령어로 실행되지 않습니다. 그저 UNION이라는 글자가 포함된 데이터로 취급될 뿐입니다. 이것이 SQL Injection 공격을 원천적으로 막는 가장 근본적인 해결책입니다.

    ---
