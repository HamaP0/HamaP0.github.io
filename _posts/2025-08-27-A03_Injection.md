---
layout: post
title: "A03:2021 - Injection (인젝션) 분석 보고서"
date: 2025-08-27 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 3. A03:2021 - Injection (인젝션) 분석 보고서**

#### **1. 취약점 개요**

**`인젝션 공격`**은 해킹의 주요 유형 중 하나로, 사용자가 입력한 값을 단순히 데이터로 처리해야 함에도 불구하고, 이 과정에서 입력된 내용이 쿼리나 명령어로 변환되어 시스템을 공격하는 모든 상황을 지칭합니다. 특히 SQL Injection은 데이터베이스에 직접적인 공격을 가하여 시스템에 가장 큰 피해를 줄 수 있는 대표적인 공격 방법입니다. 

본 보고서에서 DVWA 환경에서 점진적으로 심화되는 세 가지 SQL Injection 공격 기법`Error-Based · Union-Based · Blind`을 수행하고, 자동화 도구를 활용한 효율적인 공격에 대해 알아보고, 나아가 시큐어 코딩을 통해 근본적인 해결책을 찾아보고자 합니다.

---

#### **2. 시나리오 분석 및 재현**

**Part 1. 첫 번째 단서: 서버의 비정상적인 침묵 `Error-Based via Inference`**

*   **가설 설정:**
사용자 ID 입력란에 SQL 문법에서 특별한 의미를 갖는 기호인 작은따옴표(')를 입력하면, 서버는 이를 제대로 처리하지 못하고 예상치 못한 반응을 보일 수 있을 것이.

*   **공격 검증:**
User ID 입력 칸에 작은따옴표`'` 하나만 입력하고 전송 버튼을 누르자 화면에는 아무것도 나오지 않는 백지 페이지만 떴습니다.

   ![백지 화면](/assets/images/A03_P1-1.png)

서버의 응답을 Burp Suite로 분석한 결과, Content-Length가 0으로 설정되어 있었습니다. 이는 정상적인 응답과는 확연히 다른 모습입니다. 겉으로는 아무 일도 일어나지 않은 것처럼 보이지만, 실제로는 서버가 작은따옴표로 인해 오류를 일으키고 빈 페이지를 반환한 것입니다. 이러한 비정상적인 침묵은 해당 필드가 SQL Injection 공격에 취약할 수 있다는 중요한 단서가 됩니다.

   ![Content-Length](/assets/images/A03_P1-2.png)

**Part 2. 정보의 홍수: UNION을 이용한 데이터베이스 탈취**

*   **가설 설정:**
웹사이트의 취약점을 이용하여 UNION SQL 명령을 삽입, 원래 웹사이트 정보 뒤에 숨겨진 데이터베이스 정보(예: 전체 회원 목록)를 몰래 추가하여 한 번에 빼낼 수 있을 것이다.

*   **공격 검증:**
UNION 공격을 실행하기 전에, 원래 화면에 표시되는 정보가 몇 개의 칸으로 구성되어 있는지 확인해야 합니다. ORDER BY 명령어를 사용하여 칸의 개수를 추정한 결과, `ORDER BY 2#`를 입력했을 때는 정상적인 화면이 나타났지만, `ORDER BY 3#`을 입력했을 때는 백지 화면이 나타났습니다.

   ![orderby2](/assets/images/A03_P2-2.png)
   ![Content-Length](/assets/images/A03_P2-3.png)

이러한 반응 차이를 통해 이 페이지에서 정보를 표시하는 칸이 2개라는 것을 확신할 수 있었습니다. 이제 칸의 개수를 알았으니 해당 2개의 칸에 users 테이블의 user 아이디와 password 비밀번호를 채우도록 UNION SELECT 공격 코드를 주입했습니다. 그 결과, 단 한 번의 공격으로 데이터베이스에 저장된 모든 사용자의 아이디와 암호화된 비밀번호를 전부 빼낼 수 있었습니다.

   ![사용자 정보 탈취](/assets/images/A03_P2-1.png)

*   **위험성 분석:**
이 공격은 대규모 개인정보 유출 사고와 바로 연결됩니다. 탈취된 계정 정보는 2차, 3차 공격에 악용될 수 있으며, 기업의 신뢰도에 치명적인 타격을 입힐 수 있습니다.

**Part 3. 침묵 속의 대화: 반응의 차이로 정보 빼내기 (Blind)**

*   **가설 설정:**
만약 서버가 에러 메시지도 보여주지 않고, UNION 공격 결과도 화면에 나타나지 않는 Blind 상태에서도 SQL 질문이 '참'일 때와 '거짓'일 때 서버가 아주 미세하게 다르게 반응하는 점을 이용한다면 정보를 한 글자씩 대입해 알아낼 수 있을 것이다.

*   **공격 검증:**
 SQL Injection (Blind) 메뉴에서, 데이터베이스 버전의 첫 글자가 '8'인지 묻는 참/거짓 질문을 던졌습다.
  *   **거짓(False) 조건:** `1' AND SUBSTRING(VERSION(), 1, 1) = '1'#` 입력하니, 'User ID is MISSING...' (사용자가 없습니다) 라는 거짓을 의미하는 답변이 돌아왔습니다.
 *   **참(True) 조건:** `1' AND SUBSTRING(VERSION(), 1, 1) = '8'#` 입력하니, 'User ID is EXISTS...' (사용자가 존재합니다) 라는 참을 의미하는 답변이 돌아왔습니다.

   ![거짓](/assets/images/A03_P3-1.png)
   ![참](/assets/images/A03_P3-2.png)

이 두 가지 다른 답변을 통해, 눈에 보이지는 않지만 데이터베이스의 버전이 MySQL 8.x 버전이라는 사실을 정확하게 알아낼 수 있었습니다.

**Part 4. 실무자의 무기: 자동화 도구의 활용 `sqlmap`**

*   **가설 설정:**
 수동 분석으로 원리를 이해했다면, 자동화 도구를 활용하여 Blind SQL Injection처럼 시간이 오래 걸리는 작업을 효율적으로 수행할 수 있을 것이다.

*   **공격 검증:**
직접 찾은 공격 포인트와 로그인 정보를 sqlmap이라는 전문 도구에 알려주고 실행시키자 작업을 단 몇십 초 만에 끝내고, dvwa 데이터베이스의 users 테이블에 있는 모든 정보를 깔끔하게 가져오는 것을 볼 수 있었습니다.
    
   ![sqlmap](/assets/images/A03_P4-1.png)
   ![users table](/assets/images/A03_P4-3.png)

특히 sqlmap은 암호화된 비밀번호 중 풀기 쉬운 것은 직접 해독하여 원래 비밀번호`password, letmein`를 찾아주는 놀라운 기능도 보여주었습니다. 

   ![cracked password](/assets/images/A03_P4-2.png)

---

#### **3. 근본 원인 및 해결 방안**

*   **원인: 데이터와 명령어의 경계 붕괴**

모든 SQL Injection 공격의 진짜 원인은 사용자가 입력한 데이터와 개발자가 만든 명령어를 서버가 구분하지 못했기 때문입니다. 사용자가 입력한 값을 아무런 의심 없이 원래의 SQL 코드에 그대로 합쳐버리니, 평범한 **데이터**여야 할 입력값이 악의적인 **명령어**로 변신해서 실행되어 버리는 것입니다.

*   **해결 방안: Prepared Statement (매개변수화된 쿼리)**

이 문제를 해결하는 가장 확실하고 안전한 방법은 Prepared Statement를 사용하는 것입니다. 실제로 DVWA의 보안 레벨 high의 소스코드에서도 이 방법을 사용하고 있었습니다.

   ![소스코드](/assets/images/A03_Sourcecode.png)

 이 방식의 핵심 원리는 다음과 같습니다.
 1.  **Prepare (준비):** 먼저 SQL 코드의 틀을 만듭니다. 사용자 입력이 들어갈 자리는 ?로 비워둡니다. `SELECT * FROM users WHERE user_id = ?;` 이 양식을 먼저 데이터베이스에 보내서 '이런 형식의 명령을 내릴 거야'라고 알려줍니다.
 2.  **Bind & Execute (결합 및 실행):** 그 후에 사용자가 입력한 값을 따로 데이터베이스에 보냅니다. 데이터베이스는 이미 받아둔 틀의 `?` 자리에 입력값을 **데이터**로만 안전하게 채워 넣어 쿼리를 실행합니다.

이렇게 명령어`틀`와 데이터`내용`를 완전히 분리해서 처리하기 때문에, 공격자가 입력값에 UNION 이나 `'` 같은 공격 코드를 섞어 보내더라도 절대 명령어로 실행되지 않습니다. 그저 UNION이라는 글자가 포함된 데이터로 취급될 뿐입니다. 이것이 SQL Injection 공격을 원천적으로 막는 가장 근본적인 해결책입니다.


<hr class="short-rule">
