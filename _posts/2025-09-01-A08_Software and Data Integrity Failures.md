---
layout: post
title: "A08:2021 - Software and Data Integrity Failures <br> (소프트웨어 및 데이터 무결성 실패) 분석 보고서"
date: 2025-09-01 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 8. A08:2021 - Software and Data Integrity Failures <br> (소프트웨어 및 데이터 무결성 실패) 분석 보고서**

#### **1. 취약점 개요**

**`소프트웨어 및 데이터 무결성 실패`**는 '봉인 테이프가 뜯어진 상자를 그냥 믿고 열어보는' 모든 위험한 상황을 의미합니다. 
본 분석에서는 외부에서 가져온 소프트웨어 부품(CDN · 스크립트)의 봉인을 확인하지 않는 `소프트웨어 무결성 실패`와 우리 시스템이 만든 데이터의 봉인이 뜯어졌는지 확인하지 않는 `데이터 무결성 실패`라는 두 가지 측면에서 이 문제를 추적해 보았습니다.

---

#### **2. 시나리오 분석 및 재현**

**Part 1. 찢어진 봉인 테이프: Subresource Integrity`SRI` 누락**

*   **가설 설정:**
인터넷으로 주문한 약병의 '안전 씰'이 뜯어져 있다면, 중간에 내용물이 바뀌었을지 몰라 먹을 수 없을 것이다. 마찬가지로 웹사이트가 외부 서버(CDN)에서 가져오는 JavaScript 파일에 이런 '안전 씰'이 없다면 CDN 서버가 해킹당했을 때 우리 웹사이트는 악성코드를 아무 의심 없이 그대로 실행하게 될 것이다.

*   **분석 및 검증 (개념 증명):**
DVWA에는 해당 기능이 없으므로 개념 증명을 위한 예시 코드로 소프트웨어 무결성 실패를 분석했습니다.

1.  **취약한 코드 (안전 씰이 없는 약병):**
    웹사이트가 외부 CDN에서 중요한 JavaScript 라이브러리를 가져올 때, 아래 코드에는 파일의 무결성을 검증하는 `integrity` 속성이 없습니다. 만약 `code.jquery.com` 서버가 해킹당해 `jquery-3.6.0.min.js` 파일이 악성코드로 변조되더라도, 브라우저는 이 사실을 전혀 알지 못한 채 악성코드를 그대로 실행할 것입니다.
    ```html
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    ```

2.  **안전한 코드 (안전 씰이 붙은 약병):**
    안전한 구현은 아래와 같이 파일의 고유 지문(해시 값)을 담은 integrity 속성을 포함합니다. 만약 CDN의 파일이 단 1비트라도 변경된다면 브라우저가 계산한 지문과 `integrity` 속성의 값이 달라지게 됩니다. 브라우저는 '안전 씰'이 뜯어졌다고 판단하고, 이 스크립트의 실행을 즉시 차단하여 사용자를 보호합니다.
    ```html
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"
            integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8="
            crossorigin="anonymous"></script>
    ```

*   **위험성 분석:**
SRI 검증 누락은 심각한 공급망 공격`Supply Chain Attack`으로 이어질 수 있는 소프트웨어 무결성 실패입니다. CDN 서버 해킹이나 중간자 공격`MITM`을 통해 외부 스크립트가 변조될 경우엔 웹사이트 방문자들은 자신도 모르는 사이에 악성코드에 감염되거나 개인정보를 탈취당할 수 있습니다.

**Part 2. 실패한 가설과 그 추적의 기록: 안전하지 않은 역직렬화**

*   **1차 가설: 범인의 이름을 직접 검색하기**
    *   **가설 설정:** 이 취약점을 공부하면서, PHP 환경에서는 거의 항상 `unserialize()`라는 특정 함수가 문제의 중심에 있다는 것을 알게 되었습니다. 따라서 '소스코드 어딘가에 `unserialize()`라는 단어가 반드시 있을 것이며, 리눅스의 `grep` 명령어로 서버 전체를 탐색하면 그 흔적을 찾을 수 있을 것이다.' 라는 가설을 세웠습니다.

    *   **분석 및 검증:** DVWA가 설치된 Ubuntu 서버에 접속하여 전체 디렉토리를 대상으로 `unserialize` 키워드를 검색했으나, 예상과 달리 아무런 결과도 반환되지 않았습니다. 이 가설은 실패했지만, '최신 프레임워크처럼, 주소를 동적으로 처리하는 복잡한 구조 속에 숨겨져 있는 것은 아닐까?' 라는 새로운 의문을 갖게 했습니다.

    ![find](/assets/images/A08_P1-1.png)

*   **2차 가설: 정체불명 주소의 '비밀 지도'를 찾아서**
    *   **가설 설정:** `vulnerabilities/api/low.php` 파일에서 `.../api/v2/user/`라는 실제 파일과 다른 주소를 발견했습니다. Apache 서버에서 이런 주소 규칙을 정의하는 .htaccess 파일에 단서가 있을 것이라 판단하고 **"`.htaccess`** 파일을 분석하면 이 정체불명의 API 주소를 누가 처리하는지 알려주는지를 찾을 수 있을 것이다.' 라는 2차 가설을 세웠습니다.

    ![find htaccess](/assets/images/A08_P2-1.png)

    *   **분석 및 검증:** find 명령어로 `.htaccess` 파일을 찾아낸 뒤, 그 내용을 확인했습니다. `RewriteRule ^ public/index.php` 라는 결정적인 규칙을 통해, 이 API 폴더로 오는 모든 요청이 public/index.php 라는 단일 파일에 의해 처리됨을 알 수 있었습니다. 
    
    ![.htaccess 분석](/assets/images/A08_P2-2.png)
    
    하지만 public/index.php 부터 최종 실행 파일인 src/UserController.php까지 모두 분석한 결과, 어디에도 `unserialize` 함수는 존재하지 않았습니다. 2차 가설 역시 실패했습니다.

---

#### **3. 분석 결론: 가설 검증 실패와 그 의미**

수차례의 소스코드 역추적과 분석 끝에, DVWA 최신 버전의 API 모듈에는 안전하지 않은 역직렬화`Insecure Deserialization` 취약점이 존재하지 않음을 결론 내릴 수 있었습니다.

이번 분석은 공격 성공으로 이어지진 않았지만, 저에게는 그보다 더 값진 경험이었습니다. 취약점이 없는 상태를 확인함으로써, 역으로 안전한 상태가 무엇인지 증명하고 그 근본 원인을 고찰해 볼 수 있었습니다.

---

#### **4. DVWA의 안전한 설계 분석: 왜 취약점이 없었는가?**

가설 검증의 실패는 자연스럽게 '왜 이 시스템은 안전한가?'라는 질문으로 이어졌습니다. `UserController.php` 코드를 더 깊이 분석한 결과, 이는 우연이 아닌 명확한 설계 의도의 결과임을 알 수 있었습니다.

    ![UserController.php](/assets/images/A08_P3-1.png)
    ![json_decode](/assets/images/A08_P3-2.png)

1.  **안전한 데이터 포맷(JSON)의 선택:** 가장 근본적인 이유는 최신 DVWA의 API가 더 이상 위험 가능성이 있는 PHP 직렬화 객체를 데이터 교환 방식으로 사용하지 않고 실행 코드를 포함할 수 없는 순수한 데이터 구조인 JSON을 채택했기 때문입니다.

2.  **데이터와 코드의 명확한 분리: `json_decode()`의 역할:** 실제 코드 레벨에서 이 안전한 설계는 `json_decode()` 함수를 통해 구현됩니다. 이 함수는 외부로부터 들어온 JSON 형식의 문자열을 PHP가 다룰 수 있는 데이터 구조로 변환할 뿐, 입력값이 임의의 클래스나 코드로 해석될 여지를 원천적으로 차단합니다. 입력값은 처음부터 끝까지 **데이터**로만 취급될 뿐 절대 **실행 가능한 명령어**로 변신하지 않습니다.

3.  **결론: 예방적 통제로서의 '안전한 설계':** 결론적으로, DVWA API 모듈에 역직렬화 취약점이 없었던 이유는 단순히 보안 패치를 잘했기 때문이 아닙니다. 설계 단계에서부터 위험성이 높은 기술`unserialize`을 배제하고 안전성이 검증된 대안JSON을 채택하는 안전한 설계`Secure by Design` 원칙이 적용되었기 때문입니다.

---

#### **5. 근본 원인 및 해결 방안**

*   **원인: 검증되지 않은 외부 요소를 신뢰하는 설계**

소프트웨어 및 데이터 무결성 실패는 공통적으로 '검증되지 않은 외부 요소를 신뢰하는 것'에서 비롯됩니다. 외부 CDN 서버의 보안을 맹신하거나, 사용자가 보낸 데이터가 조작되지 않았을 것이라고 믿는 순간 무결성은 깨지게 됩니다.

*   **해결 방안: 설계 단계부터의 무결성 확보**

1.  **소프트웨어 무결성 확보 (SRI 적용):** 외부에서 로드하는 모든 제3자 리소스에 대해 Subresource Integrity`SRI`를 의무적으로 적용하여 브라우저가 직접 파일의 무결성을 검증하도록 강제해야 합니다.
2.  **데이터 무결성 확보 (안전한 데이터 포맷 사용):** JSON과 같이 실행 코드를 포함할 수 없는 안전한 데이터 전용 포맷을 사용하고, `json_decode()`처럼 코드 실행 가능성이 없는 안전한 `Parser`를 사용해야 합니다. 궁극적으로 이는 설계 단계에서부터 위험 요소를 배제하는 **안전한 설계Secure by Design** 원칙을 적용하는 것이 가장 이상적인 해결책입니다.

<hr class="short-rule">