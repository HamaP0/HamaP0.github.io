---
layout: post
title: "A08:2021 - Software and Data Integrity Failures <br> (소프트웨어 및 데이터 무결성 실패) 분석 보고서"
date: 2025-09-01 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 8. A08:2021 - Software and Data Integrity Failures <br> (소프트웨어 및 데이터 무결성 실패) 분석 보고서**

#### **1. 취약점 개요**

'소프트웨어 및 데이터 무결성 실패'는 '봉인 테이프가 뜯어진 상자를 그냥 믿고 열어보는' 모든 위험한 상황을 의미합니다. 특히 데이터 무결성 실패의 대표적인 사례인 '안전하지 않은 역직렬화(Insecure Deserialization)'는, 공격자가 조작한 데이터 덩어리를 서버가 아무런 의심 없이 처리하다가 원격 코드 실행(RCE)과 같은 치명적인 결과로 이어질 수 있는 취약점입니다.

이번 분석에서는 DVWA 최신 버전에 포함된 `API` 모듈이 현대적인 구조를 가진 만큼, 대표적인 API 취약점 중 하나인 '안전하지 않은 역직렬화'가 존재할 것이라는 가설을 세우고 그 흔적을 추적해 보았습니다.

---

#### **2. 시나리오 분석 및 재현: 실패한 가설과 그 추적의 기록**

**Part 1. 첫 번째 가설: 범인의 이름을 직접 검색하기**

*   **가설 설정:**
이 취약점을 공부하면서, PHP 환경에서는 거의 항상 `unserialize()`라는 특정 함수가 문제의 중심에 있다는 것을 알게 되었습니다. 마치 범죄 현장에 범인의 이름이 적힌 증거물이 남는 것과 같다고 생각했습니다. 그래서 저의 첫 번째 가설은 다음과 같습니다.: **"만약 이 취약점이 있다면, 소스코드 어딘가에 `unserialize()`라는 단어가 반드시 있을 것이다. 리눅스의 `grep` 명령어로 서버 전체를 샅샅이 뒤지면 그 흔적을 찾을 수 있을 것이다.**

*   **분석 및 검증:**
가장 먼저, DVWA가 설치된 Ubuntu 서버에 접속하여 전체 디렉토리를 대상으로 `unserialize` 키워드를 검색하는 `grep` 명령어를 실행했습니다. 예상과 달리, 명령어는 아무런 결과도 반환하지 않았습니다.

   ![unserialize](/assets/images/A08_P1-1.png)

이는 DVWA 내에 `unserialize` 함수가 눈에 띄게 사용된 곳은 없다는 1차적인 결론을 의미했습니다. 이 결과는 저를 당황하게 했지만, 동시에 다른 가능성을 생각하게 만들었습니다. "혹시 최신 웹 프레임워크처럼, 주소를 동적으로 처리하는 복잡한 구조 속에 숨겨져 있는 것은 아닐까?"

**Part 2. 두 번째 가설: 정체불명 주소의 '비밀 지도'를 찾아서**

*   **가설 설정:**
첫 번째 가설이 실패로 돌아가자, 저는 원점으로 돌아와 `vulnerabilities/api/low.php` 파일 자체를 열어보았습니다. 그런데 이상하게도 파일 안에는 실제 데이터를 처리하는 PHP 코드가 거의 보이지 않았습니다. 대신 JavaScript 코드에서 `.../api/v2/user/`라는, 파일 이름처럼 보이지 않는 주소로 요청을 보내는 것을 발견했습니다. 이것을 보고 '아, 이건 보이는 주소와 실제 실행되는 파일이 다른 라우팅 구조일 수 있겠다'는 생각이 들었습니다. Apache 서버 환경에서 이런 주소 규칙을 정의하는 파일이 바로 `.htaccess`라는 것을 떠올렸습니다. 그래서 두 번째 가설을 세웠습니다: **"`.htaccess` 파일을 분석하면, 이 정체불명의 API 주소를 누가 처리하는지 알려주는 '비밀 지도'를 찾을 수 있을 것이다."**

*   **분석 및 검증:**
서버에서 `.htaccess` 파일을 찾아 그 내용을 확인했습니다. `RewriteRule ^ public/index.php` 라는 결정적인 규칙을 통해, 이 API 폴더로 오는 모든 요청이 `public/index.php` 라는 단일 파일에 의해 처리됨을 알 수 있었습니다.

   ![RewriteRule](/assets/images/A08_P2-2.png)

다시 `public/index.php` 파일을 분석한 결과, 최종적으로 `src/UserController.php` 파일이 실제 요청을 처리한다는 사실까지 파고들 수 있었습니다. 하지만 `UserController.php` 파일의 내용 어디에도 `unserialize` 함수는 존재하지 않았습니다. 저의 가설은 또다시 실패했습니다

---

#### **3. 분석 결론: 가설 검증 실패와 그 의미**

수차례의 소스코드 역추적과 분석 끝에, **DVWA 최신 버전의 API 모듈에는 '안전하지 않은 역직렬화(Insecure Deserialization)' 취약점이 존재하지 않음**을 결론 내릴 수 있었습니다.

이번 분석은 공격 성공으로 이어지진 않았지만, 저에게는 그보다 더 값진 경험이었습니다. 취약점이 '없는' 상태를 확인함으로써, 역으로 **'안전한 상태'가 무엇인지 증명**하고 그 근본 원인을 고찰해 볼 수 있었습니다. 이 경험을 통해 배운 점은 다음과 같습니다.

*   **문제 해결 능력의 심화:** 첫 가설이 실패했을 때 `grep`에서 멈추지 않고, `.htaccess` 분석과 같은 다른 방법으로 계속해서 파고드는 경험을 통해, 눈에 보이지 않는 문제의 본질에 접근하는 분석력을 기를 수 있었습니다.
*   **'안전함'에 대한 증명:** 이번 분석은 단순히 취약점을 찾는 것을 넘어, 특정 시스템이 '왜 안전한가'를 코드를 통해 증명해내는 값진 경험이었습니다.

---

#### **4. DVWA의 안전한 설계 분석: 왜 취약점이 없었는가?**

가설 검증의 실패는 자연스럽게 '왜 이 시스템은 안전한가?'라는 질문으로 이어졌습니다. `UserController.php` 코드를 더 깊이 분석한 결과, 이는 우연이 아닌 명확한 설계 의도의 결과임을 알 수 있었습니다.

1.  **안전한 데이터 포맷(JSON)의 선택**
가장 근본적인 이유는, 최신 DVWA의 API가 더 이상 위험 가능성이 있는 PHP 직렬화 객체를 데이터 교환 방식으로 사용하지 않기 때문입니다. 대신, **실행 코드를 포함할 수 없는 순수한 데이터 구조인 JSON을 채택**했습니다. PHP의 `unserialize()` 함수는 문자열을 통해 객체를 생성하고 특정 메소드를 자동으로 실행시킬 수 있어 RCE 공격의 빌미를 제공하지만, JSON은 단순히 데이터의 구조(Key-Value)만을 정의할 뿐입니다.

2.  **데이터와 코드의 명확한 분리: `json_decode()`의 역할**
실제 코드 레벨에서 이 안전한 설계는 `json_decode()` 함수를 통해 구현됩니다. 이 함수는 외부로부터 들어온 JSON 형식의 문자열을 PHP가 다룰 수 있는 배열이나 객체로 변환해주는 역할을 합니다. 중요한 것은, 이 과정에서 **입력값이 임의의 클래스나 코드로 해석될 여지를 원천적으로 차단**한다는 점입니다. 입력값은 처음부터 끝까지 '데이터'로만 취급될 뿐, 절대 '실행 가능한 명령어'로 변신하지 않습니다.

   ![UserController.php](/assets/images/A08_P3-1.png)
   ![json_decode](/assets/images/A08_P3-2.png)

위 코드에서 볼 수 있듯이, 외부 입력은 오직 `json_decode`를 통해서만 내부 로직에 전달됩니다. 이는 '외부로부터 받은 데이터는 신뢰해서는 안 된다'는 원칙을 함수 수준에서부터 철저히 지키고 있는 모범적인 사례입니다.

3.  **결론: 예방적 통제로서의 '안전한 설계'**
결론적으로, DVWA API 모듈에 역직렬화 취약점이 없었던 이유는 단순히 보안 패치를 잘했기 때문이 아닙니다. 설계 단계에서부터 **위험성이 높은 기술(`unserialize`)을 배제하고, 안전성이 검증된 대안(JSON)을 채택하는 '안전한 설계(Secure by Design)' 원칙**이 적용되었기 때문입니다. 이는 문제가 발생한 뒤에 고치는 대응적 통제가 아닌, 문제가 발생할 소지 자체를 없애는 가장 이상적인 형태의 예방적 통제라고 할 수 있습니다.

    ---
