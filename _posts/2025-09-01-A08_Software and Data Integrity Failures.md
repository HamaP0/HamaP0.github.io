---
layout: post
title: "A08:2021 - Software and Data Integrity Failures <br> (소프트웨어 및 데이터 무결성 실패) 분석 보고서"
date: 2025-09-01 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 8. A08:2021 - Software and Data Integrity Failures <br> (소프트웨어 및 데이터 무결성 실패) 분석 보고서**

### 1. 취약점 개요

   소프트웨어 및 데이터 무결성 실패는 '배송된 의약품 상자의 봉인 테이프가 뜯어져 있는데도 내용물을 의심 없이 신뢰하는 것'과 같은 모든 상황을 의미합니다. 이는 외부에서 가져온 소프트웨어`소프트웨어 무결성`나 사용자가 보낸 데이터`데이터 무결성`가 중간에 위변조되지 않았다는 보장이 없을 때 발생합니다. 이 취약점은 악성코드 유포의 경로가 되거나 애플리케이션이 예기치 않은 코드를 실행하여 시스템 전체를 장악당하는 심각한 원격 코드 실행(RCE) 공격으로 이어질 수 있습니다.
    
   본 보고서는 외부 스크립트 변조를 막는 `SRI`의 중요성을 분석하고 특히 데이터 무결성 실패의 핵심인 '안전하지 않은 역직렬화' 취약점의 존재 여부를 소스코드 역추적을 통해 집요하게 추적하고 그 과정에서 발견한 안전한 설계 원리를 증명합니다.

---

### 2. 시나리오 분석 및 재현

#### Part 1. [소프트웨어 무결성] 외부 스크립트 변조를 막는 `SRI`Subresource Integrity의 부재

*   **공격 시나리오:**
   웹사이트가 외부 CDN 서버에서 JavaScript 라이브러리를 가져올 때 파일의 무결성을 검증하는 장치(SRI)가 없다면 CDN 서버가 해킹당했을 경우 우리 웹사이트는 변조된 악성코드를 아무 의심 없이 그대로 실행하게 될 것이다.

*   **분석 및 검증 (개념 증명):**
   *   **취약한 코드:** 아래 코드는 외부 스크립트를 가져오지만 파일의 고유 지문(해시)을 검증하는 `integrity` 속성이 없습니다. `code.jquery.com` 서버가 해킹당하면 이 스크립트는 악성코드로 대체될 수 있습니다.
         ```html
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
         ```

   *   **안전한 코드:** 안전한 구현은 아래와 같이 `integrity` 속성에 미리 계산된 해시 값을 포함합니다. 만약 파일 내용이 단 1비트라도 변경되면 브라우저는 해시 값이 다르다고 판단하고 이 스크립트의 실행을 즉시 차단하여 사용자를 보호합니다.
         ```html
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"
                integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8="
                crossorigin="anonymous"></script>
        ```

*   **위험성 분석:**
   SRI 검증 누락은 심각한 공급망 공격(Supply Chain Attack)으로 이어질 수 있는 소프트웨어 무결성 실패입니다. 웹사이트 방문자들은 자신도 모르는 사이에 악성코드에 감염되거나 개인정보를 탈취당할 수 있습니다.

>  외부에서 가져오는 소프트웨어의 무결성을 검증하지 않는 것은 심각한 공급망 공격으로 이어질 수 있습니다. 그렇다면 사용자가 서버로 보내는 데이터의 무결성은 어떻게 다루어야 할까요?

#### Part 2. [데이터 무결성] 안전하지 않은 역직렬화 Deserialization 취약점 탐색과 실패의 기록

*   **공격 시나리오:**
   데이터 무결성 실패의 가장 대표적인 사례인 '안전하지 않은 역직렬화' 취약점은 주로 `unserialize()`와 같은 위험한 함수를 통해 발생한다. 따라서 DVWA 소스코드 전체에서 `unserialize` 키워드를 검색하고 관련 API의 흐름을 역추적하면 취약점의 존재 여부를 확인할 수 있을 것이다.

*   **분석 및 검증 (가설 검증 실패):**
   1.  **1차 가설 검증:** `grep` 명령어로 서버 전체에서 `unserialize` 키워드를 검색했으나 아무 결과도 발견되지 않았습니다.

   ![grep](/assets/images/A08_P1-1.png)

   2.  **2차 가설 검증:** `vulnerabilities/api/` 경로의 동적 라우팅 구조를 파악하고 `.htaccess` 파일 분석을 통해 실제 요청이 `public/index.php`로 전달됨을 확인했습니다. 최종 실행 파일인 `src/UserController.php`까지 모든 흐름을 분석했지만 어디에도 `unserialize` 함수는 존재하지 않았습니다.

   ![find htaccess](/assets/images/A08_P2-1.png)
   ![.htaccess 분석](/assets/images/A08_P2-2.png)
    
*   **분석 결론: "취약점이 없음"을 증명하다**
   수차례의 소스코드 역추적 끝에 DVWA 최신 버전의 API 모듈에는 안전하지 않은 역직렬화 취약점이 존재하지 않음을 결론 내렸습니다. 이 실패의 과정은 저에게 공격 성공보다 더 값진 경험이었습니다. 취약점이 없는 상태를 확인함으로써 역으로 '안전한 상태란 무엇인가'를 증명하고 그 근본 원인을 고찰해 볼 수 있었습니다.
    
---

### 3. DVWA의 안전한 설계 분석: 왜 취약점이 없었는가?

   가설 검증의 실패는 자연스럽게 '왜 이 시스템은 안전한가?'라는 질문으로 이어졌습니다. `UserController.php` 코드를 더 깊이 분석한 결과 이는 우연이 아닌 명확한 설계 의도의 결과임을 알 수 있었습니다.

   ![UserController.php](/assets/images/A08_P3-1.png)
   ![json_decode](/assets/images/A08_P3-2.png)

1.  **안전한 데이터 포맷JSON의 선택:**
   가장 근본적인 이유는 최신 DVWA의 API가 더 이상 위험 가능성이 있는 PHP 직렬화 객체를 사용하지 않고 실행 코드를 포함할 수 없는 순수한 데이터 구조인 **JSON**을 채택했기 때문입니다.

2.  **데이터와 코드의 명확한 분리 `json_decode`:**
   실제 코드 레벨에서 이 안전한 설계는 **`json_decode()`** 함수를 통해 구현됩니다. 이 함수는 외부로부터 들어온 JSON 문자열을 PHP 데이터 구조로 변환할 뿐 입력값이 임의의 코드로 해석될 여지를 원천적으로 차단합니다. 입력값은 처음부터 끝까지 **데이터**로만 취급될 뿐 절대 **실행 가능한 명령어**로 변신하지 않습니다.

---

### 4. 원인 및 해결 방안

*   **원인: 검증되지 않은 외부 요소를 신뢰하는 설계**

   소프트웨어 및 데이터 무결성 실패는 공통적으로 '검증되지 않은 외부 요소를 신뢰하는 것'에서 비롯됩니다. 외부 CDN 서버의 보안을 맹신하거나 사용자가 보낸 데이터가 조작되지 않았을 것이라고 믿는 순간 무결성은 깨지게 됩니다.

*   **해결 방안: 설계 단계부터의 무결성 확보 (Secure by Design)**

   1.  **소프트웨어 무결성 확보 `SRI` 적용:** 외부에서 로드하는 모든 제3자 리소스에 대해 Subresource Integrity(SRI)를 의무적으로 적용하여 브라우저가 직접 파일의 무결성을 검증하도록 강제해야 합니다.
   2.  **데이터 무결성 확보 `안전한 데이터 포맷 사용`:** JSON과 같이 실행 코드를 포함할 수 없는 안전한 데이터 전용 포맷을 사용하고 `json_decode()`처럼 코드 실행 가능성이 없는 안전한 파서(Parser)를 사용해야 합니다. 이는 설계 단계에서부터 위험 요소를 배제하는 **안전한 설계(Secure by Design)** 원칙을 적용하는 가장 이상적인 해결책입니다.

---

### 5. 시큐어 코딩: 코드 레벨 분석

**분석 대상:** DVWA - Insecure Deserialization

#### 취약한 코드 예시

   ![]({{ "/assets/images/A08_secure_code_low.png" | relative_url }})  

   *   **코드 분석:** 이 가상의 코드는 **`$_COOKIE['profile']`** 처럼 사용자가 직접 제어할 수 있는 입력값을 위험한 **`unserialize()`** 함수의 인자로 직접 전달합니다. 이는 공격자가 특수하게 조작된 객체를 주입하여 원격 코드 실행(RCE) 공격을 수행할 수 있는 심각한 취약점입니다.

#### 안전한 코드 분석 DVWA API

   ![json_decode](/assets/images/A08_P3-2.png)

   *   **코드 분석:** DVWA의 실제 API 코드는 위험한 `unserialize()` 함수 자체를 사용하지 않습니다. 대신 데이터 교환 포맷으로 **JSON**을 사용하고 이를 처리하기 위해 안전한 **`json_decode()`** 함수를 사용합니다. 이 함수는 순수한 데이터만 처리하므로 역직렬화 공격의 근본적인 원인을 제거합니다.

#### **핵심 방어 원리**

   결론적으로 데이터 무결성 실패의 핵심 방어 원리는 **안전한 데이터 포맷의 선택** 입니다. 객체 직렬화처럼 코드 실행 가능성이 내포된 데이터 포맷의 사용을 지양하고 JSON처럼 데이터와 코드가 명확히 분리된 포맷을 사용하는 것이 설계 단계에서 위험을 원천적으로 제거하는 가장 좋은 방법입니다.

<hr class="short-rule">