---
layout: post
title: "A10:2021 - Server-Side Request Forgery (서버 측 요청 위조) 분석 보고서"
date: 2025-09-03 17:00:00 +0900
categories: [OWASP Top 10]
---
---

### **프로젝트 10.A10:2021 - Server-Side Request Forgery (SSRF) 분석 보고서**

### 1. 취약점 개요

   서버 측 요청 위조`SSRF`는 공격자가 서버를 '내부 스파이'로 만들어 원래는 접근할 수 없는 내부망이나 자기 자신(localhost)에게 대신 요청을 보내도록 조종하는 공격입니다. 이는 방화벽이라는 경비원이 외부인의 접근을 철저히 막고 있더라도 이미 내부에 있는 서버를 조종하여 방화벽 너머의 민감 정보를 훔쳐보게 만드는 것과 같습니다. 이 취약점은 내부 시스템 정보 유출은 물론 클라우드 환경에서는 인프라 전체의 권한을 탈취하는 치명적인 위협으로 이어질 수 있습니다.

   본 보고서는 초기 공격 시도가 서버 설정에 의해 막혔을 때 다른 공격 벡터로 전환하고 소스코드 분석을 통해 방어 로직을 우회하여 최종적으로 SSRF 공격을 성공시키는 현실적인 문제 해결 과정을 증명합니다.

---

### 2. 시나리오 분석 및 재현: 우회 전략의 수립과 증명

#### Part 1. [공격 벡터 탐색] 공격 경로 탐색과 서버의 1차 방어 확인

*   **공격 시나리오:**
   외부 URL을 포함할 수 있는 기능은 SSRF의 주요 공격 경로가 된다. 따라서 `File Inclusion` 모듈을 통해 외부 URL을 요청하면 서버가 대신 해당 URL에 접속하여 그 결과를 반환하도록 만들 수 있을 것이다.

*   **분석 및 검증 (공격 실패 및 전환):**
   가장 먼저 `File Inclusion` 모듈을 공격 벡터로 탐색했으나 서버의 PHP 설정`allow_url_include=Off` 단에서 기능이 원천적으로 비활성화되어 있어 공격이 불가능했습니다. 이는 '안전한 기본 설정Secure by Default' 원칙에 따른 훌륭한 방어 사례였습니다.

   이에 서버가 직접 쉘 명령어를 실행하는 `Command Injection` 모듈로 공격 벡터를 전환 **Pivot** 했습니다. 이 모듈이라면 서버가 직접 외부와 통신하는 명령을 내리게 할 수 있을 것이라 판단했습니다.

*   **위험성 분석:**
   초기 공격의 실패는 끝이 아니라 새로운 시작입니다. 방어자는 여러 경로를 통해 들어올 수 있는 공격 가능성을 모두 고려해야 하며 공격자는 하나의 경로가 막혔을 때 다른 취약점을 연계하여 목표를 달성하는 능력이 중요합니다.

>  새로운 공격 경로를 찾았지만 일반적인 명령어 주입 페이로드는 모두 실패했습니다. 공격의 성공 여부는 이제 소스코드에 숨겨진 시스템의 동작 원리를 파악할 수 있느냐에 달려있었습니다.

#### Part 2. [우회 전략 수립] 소스코드 분석을 통한 필터링 우회 기법 발견

*   **공격 시나리오:**
   `&&`나 `|` 같은 일반적인 명령어 체이닝이 실패하는 원인을 파악하기 위해 소스코드를 직접 분석한다. 코드의 구조적 특징을 역이용하여 필터링을 우회하고 새로운 명령을 실행할 수 있는 페이로드를 구성할 수 있을 것이다.

*   **분석 및 검증:**
   `Security Level: Low`의 소스코드를 분석한 결과 모든 입력값`$target`이 `ping -c 4` 라는 문자열 뒤에 붙어서 실행되는 구조임을 확인했습니다. 이 때문에 `&&`나 `|` 같은 연산자가 의도대로 해석되지 않았던 것입니다.

   이 제약을 벗어나기 위해 앞선 명령어의 성공 여부와 관계없이 명령을 종료하고 새로운 명령을 시작하는 세미콜론`;` 구분자를 활용하는 전략을 수립했습니다. `127.0.0.1; whoami` 페이로드를 테스트한 결과 `www-data`가 성공적으로 출력되어 이 우회 전략이 유효함을 증명했습니다.

   ![whoami](/assets/images/A10_P2-2.png)

*   **위험성 분석:**
   소스코드 접근이 가능하다면 공격자는 방어 로직의 허점을 정확히 파악하여 정교한 우회 공격을 수행할 수 있습니다. 이는 블랙박스 테스트의 한계를 보여주며 시큐어 코딩의 중요성을 다시 한번 강조합니다.

>  세미콜론을 이용해 명령어 제약을 우회할 수 있다는 사실을 확인했습니다. 이제 이 우회 기법을 활용하여 서버가 외부 인터넷과 통신하도록 만드는 최종 공격을 시도합니다.

#### Part 3. [최종 공격 성공] 서버를 조종하여 외부와 통신 성공 및 증거 확보

*   **공격 시나리오:**
   우회 페이로드에 `curl`이나 `wget`과 같은 명령어를 결합하여 서버가 외부 인터넷의 특정 주소`ifconfig.me`와 통신하도록 만든다. 서버의 응답에 외부 서버가 반환한 내용(서버의 공인 IP)이 포함된다면 SSRF 공격이 성공했음을 증명할 수 있다.

*   **분석 및 검증:**
   `curl`을 이용한 시도는 실패했으나 `which wget` 페이로드를 통해 서버에 `wget`이 설치된 사실을 확인했습니다. 이를 활용한 최종 페이로드 `127.0.0.1; wget -qO- ifconfig.me` 를 주입하자 마침내 서버가 외부 서버와 통신하고 받아온 응답(서버의 공인 IP 주소)이 화면에 출력되었습니다.

   ![ifconfig.me](/assets/images/A10_P3-2.png)
   ![interface](/assets/images/A10_P3-3.png)

*   **위험성 분석:**
   이 SSRF 공격 성공은 명백한 증거로 증명됩니다.
   1.  **공인 IP 주소 출력:** 서버가 방화벽을 넘어 외부 인터넷과 통신했음을 의미합니다.
   2.  **User-Agent `Wget/1.21.4`:** 이 요청이 제 브라우저가 아닌 서버 내부의 `wget` 프로그램을 통해 시작되었다는 결정적인 증거**Smoking Gun**입니다. 이를 통해 공격자는 내부망을 스캔하거나 클라우드 메타데이터를 탈취하는 등의 심각한 추가 공격을 수행할 수 있습니다.

---

### 3. 원인 및 해결 방안

*   **원인: 신뢰 경계의 부재**

   이번 공격의 근본 원인은 `Command Injection` 취약점이었지만 SSRF 관점의 핵심 원인은 '서버가 시작하는 아웃바운드 Outbound 요청의 목적지를 아무런 의심 없이 신뢰했다'는 것입니다. 서버는 공격자가 제공한 `ifconfig.me`라는 목적지가 안전한지, 내부망 주소는 아닌지 전혀 검증하지 않았습니다.

*   **해결 방안: 신뢰 경계의 명확한 설정 (Zero Trust)**

   SSRF에 대한 방어는 제로 트러스트 원칙에 입각하여 서버가 보내는 모든 외부 요청을 철저히 검증하는 것에서 시작합니다.
   1.  **화이트리스트 기반 접근 제어:** 가장 강력한 방법은 서버가 요청을 보낼 수 있는 도메인과 포트의 목록 Whitelist을 미리 정해두고 이 목록에 없는 요청은 모두 차단하는 것입니다.
   2.  **입력값 검증:** 사용자가 URL을 입력해야 한다면 입력된 URL을 표준 라이브러리로 파싱하고 그 결과로 나온 IP 주소가 내부망 대역이나 로컬호스트에 해당하는지 반드시 검사해야 합니다.
   3.  **네트워크 격리:** 서버가 꼭 필요한 경우가 아니라면 외부 인터넷으로 나가는 아웃바운드 트래픽을 방화벽에서 기본적으로 차단해야 합니다. 특히 클라우드 환경에서는 메타데이터 서비스 IP로의 접근을 애플리케이션 서버에서 원천적으로 차단하는 네트워크 정책을 적용해야 합니다.

---

### 4. 시큐어 코딩: 코드 레벨 분석

**분석 대상:** DVWA - Command Injection

#### 취약한 코드 분석 Low Level

   ![]({{ "/assets/images/A9_S-1.png" | relative_url }})

   *   **코드 분석:** 이 코드는 `SSRF` 공격의 완벽한 **진입점 Entry Point**을 제공합니다. `$_REQUEST['ip']` 변수에 대해 쉘 메타 문자` | & ; `에 대한 어떠한 방어 로직도 구현하지 않았습니다. 이로 인해 공격자는 세미콜론`;`을 이용해 원래의 ping 명령을 무력화하고 `wget`이나 `curl`과 같은 새로운 명령어를 주입할 수 있습니다. 결국 이 Command Injection 취약점이 서버가 공격자가 지정한 외부 주소로 요청을 보내도록 만드는 SSRF 공격을 가능하게 하는 직접적인 원인이 됩니다.

#### 안전한 코드 분석 Impossible Level

   ![]({{ "/assets/images/A09_S-2.png" | relative_url }})  

   *   **코드 분석:** 안전한 코드는 '화이트리스트' 기반의 엄격한 입력값 검증을 통해 Command Injection의 가능성을 원천적으로 제거함으로써 SSRF 공격 경로를 차단합니다. **`explode()`**와 **`is_numeric()`** 함수를 통해 입력값이 오직 **숫자와 점으로만 이루어진 IPv4 주소 형식**일 때만 명령어를 실행하도록 강제합니다. 쉘 메타 문자를 포함한 모든 비정상적인 입력이 차단되므로 `wget`과 같은 외부 통신 명령어를 주입하는 것이 불가능해져 SSRF 공격 시도 자체가 무력화됩니다.

#### 핵심 방어 원리

   결론적으로 SSRF를 유발할 수 있는 명령어 인젝션의 핵심 방어 원리는 **`엄격한 입력값 검증`** 입니다. 허용할 것만 정의하는 화이트리스트 방식은 예측 불가능한 모든 악의적인 입력을 효과적으로 차단하는 가장 좋은 방법입니다. SSRF 관점에서는 서버가 생성하는 아웃바운드 트래픽은 기본적으로 신뢰하지 않고 요청 가능한 목적지를 화이트리스트로 관리하는 것이 근본적인 방어 전략입니다.

<hr class="short-rule">