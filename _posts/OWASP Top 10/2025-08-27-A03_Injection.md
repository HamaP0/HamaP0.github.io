---
layout: post
title: "A03:2021 - Injection (인젝션) 분석 보고서"
date: 2025-08-27 17:00:00 +0900
categories: [OWASP Top 10]
---
---

### **프로젝트 3. A03:2021 - Injection (인젝션) 분석 보고서**

### 1. 취약점 개요

   인젝션은 사용자의 요청서(데이터)에 몰래 숨겨둔 명령서(코드)를 시스템이 구분하지 못하고 그대로 실행하게 만드는 공격입니다. 이는 마치 은행 창구에 제출한 입금 신청서 뒷면에 '금고를 열어라'라는 메모를 적었더니 은행원이 이를 공식적인 명령으로 착각하고 금고를 열어주는 것과 같습니다. 이 취약점은 데이터베이스의 모든 정보를 유출시키거나 서버를 파괴할 수 있는 가장 강력하고 파급력 높은 공격 중 하나입니다.

   본 보고서는 서버의 작은 반응 차이로 취약점을 식별하고 점차 고도화된 기법으로 데이터베이스를 장악한 뒤 최종적으로는 자동화 도구를 통해 공격을 완성하는 과정을 보여줍니다.

---

### 2. 시나리오 분석 및 재현

#### Part 1. [취약점 식별] 서버의 비정상적인 반응으로 SQL 인젝션 가능성 확인

*   **공격 시나리오:**
   사용자 ID 입력란에 SQL 문법에서 특별한 의미를 갖는 작은따옴표`'`를 주입했을 때 서버가 정상적인 응답 대신 오류나 비정상적인 반응을 보인다면 해당 입력 파라미터가 SQL 인젝션에 취약할 가능성이 높다고 판단할 수 있다.

*   **공격 검증:**
   User ID 입력란에 작은따옴표`'` 하나만 입력하자 화면에는 아무 내용도 없는 빈 페이지만 반환되었습니다. Burp Suite로 확인한 결과 서버 응답의 `Content-Length`가 0으로 이는 정상적인 응답과 명백히 다른 모습입니다. 이러한 비정상적인 침묵은 해당 필드가 SQL 인젝션 공격에 취약할 수 있다는 결정적인 단서입니다.

   ![백지 화면](/assets/images/A03_P1-1.png)

   서버의 응답을 Burp Suite로 분석한 결과 Content-Length가 0으로 설정되어 있었습니다. 이는 정상적인 응답과는 확연히 다른 모습입니다. 겉으로는 아무 일도 일어나지 않은 것처럼 보이지만 실제로는 서버가 작은따옴표로 인해 오류를 일으키고 빈 페이지를 반환한 것입니다. 이러한 비정상적인 침묵은 해당 필드가 SQL Injection 공격에 취약할 수 있다는 중요한 단서가 됩니다.

   ![Content-Length](/assets/images/A03_P1-2.png)

*   **위험성 분석:**
   이 단계는 직접적인 정보 유출은 없지만 공격의 성패를 가르는 가장 중요한 과정입니다. 공격자는 이 미세한 반응 차이를 통해 시스템의 어느 부분이 약한지 정확히 식별하고 다음 단계의 공격을 계획할 수 있습니다.
    
   서버의 비정상적인 침묵은 '이곳에 문이 있다'는 사실을 알려주었습니다. 이제 그 문을 열고 들어가 방 안의 모든 정보를 가져올 차례입니다.

#### Part 2. [정보 탈취] UNION 공격으로 데이터베이스 내 모든 사용자 정보 유출

*   **공격 시나리오:**
   식별된 취약점에 `UNION` SQL 구문을 주입하여 기존 쿼리 결과에 데이터베이스의 민감 정보(사용자 테이블)를 덧붙여 한 번의 요청으로 모든 사용자 정보를 탈취할 수 있을 것이다.

*   **공격 검증:**
   먼저 `ORDER BY` 구문을 이용해 페이지가 2개의 컬럼으로 구성되어 있음을 확인했습니다. 이 구조에 맞춰 `users` 테이블의 `user`와 `password`를 조회하는 `UNION SELECT` 공격 코드를 주입하자 데이터베이스에 저장된 모든 사용자의 아이디와 암호화된 비밀번호가 화면에 노출되었습니다.

   ![orderby2](/assets/images/A03_P2-2.png)
   ![사용자 정보 탈취](/assets/images/A03_P2-1.png)

*   **위험성 분석:**
   이 공격은 대규모 개인정보 유출 사고와 직결됩니다. 탈취된 계정 정보는 2차, 3차 공격에 악용될 수 있으며 기업의 신뢰도에 치명적인 타격을 입힙니다.

>  하지만 만약 서버가 에러 메시지는 물론 UNION 공격의 결과조차 화면에 보여주지 않는다면 어떻게 정보를 빼낼 수 있을까요?

#### Part 3. [우회 기법] 참/거짓`Boolean` 반응 분석으로 숨겨진 정보 추출

*   **가설 설정:**
   만약 서버가 에러 메시지도 보여주지 않고 UNION 공격 결과도 화면에 나타나지 않는 Blind 상태에서도 SQL 질문이 '참'일 때와 '거짓'일 때 서버가 아주 미세하게 다르게 반응하는 점을 이용한다면 정보를 한 글자씩 대입해 알아낼 수 있을 것이다.

   **공격 시나리오:**
   서버가 공격 결과를 직접 보여주지 않는 Blind 환경에서도 SQL 쿼리의 참/거짓 조건에 따라 서버가 다르게 반응하는 점을 이용하면 정보를 한 글자씩 추측하여 알아낼 수 있을 것이다.

*   **공격 검증:**
   데이터베이스 버전의 첫 글자가 '8'인지 묻는 질문을 주입했습니다.
   *   **참(True) 조건:** `... VERSION(), 1, 1) = '8'#` 입력 시 'User ID is EXISTS' 응답
   *   **거짓(False) 조건:** `... VERSION(), 1, 1) = '1'#` 입력 시 'User ID is MISSING' 응답

   이 두 가지 다른 응답을 통해 눈에 보이지 않는 데이터베이스의 버전이 MySQL 8.x임을 정확히 알아낼 수 있었습니다.

   ![참](/assets/images/A03_P3-2.png)
   ![거짓](/assets/images/A03_P3-1.png)

*   **위험성 분석:**
   블라인드 SQL 인젝션은 공격이 매우 느리고 어렵지만 성공한다면 UNION 공격과 동일하게 데이터베이스의 모든 정보를 탈취할 수 있습니다. 방어자가 공격 흔적을 찾기 더 어렵다는 특징도 있습니다.

>  이처럼 수동으로 블라인드 인젝션을 수행하는 것은 엄청난 시간이 소요됩니다. 실무에서 공격자는 이 과정을 자동화하여 공격의 효율을 극대화합니다.

#### Part 4. [공격 자동화] `Sqlmap`을 활용한 블라인드 인젝션 공격 효율 극대화

*   **공격 시나리오:**
   수동 분석으로 확인한 취약점 포인트를 전문 자동화 도구`sqlmap`에 전달하여 블라인드 SQL 인젝션 공격을 자동으로 수행하고 데이터베이스 전체를 덤프할 수 있을 것이다.

*   **공격 검증:**
   sqlmap에 취약한 URL과 쿠키 값을 전달하여 실행하자 단 몇십 초 만에 블라인드 인젝션 공격을 완료하고 `dvwa` 데이터베이스의 `users` 테이블 정보를 모두 추출했습니다. 심지어 MD5로 해시된 비밀번호 일부는 원래 값으로 자동 복호화하여 보여주었습니다.
   
   ![sqlmap](/assets/images/A03_P4-1.png)
   ![users table](/assets/images/A03_P4-3.png)

   특히 sqlmap은 암호화된 비밀번호 중 풀기 쉬운 것은 직접 해독하여 원래 비밀번호`password letmein`를 찾아주는 놀라운 기능도 보여주었습니다. 

   ![cracked password](/assets/images/A03_P4-2.png)

*   **위험성 분석:**
   자동화 도구의 존재는 SQL 인젝션 공격의 진입 장벽을 크게 낮춥니다. 이는 숙련된 해커가 아니더라도 시스템에 심각한 피해를 줄 수 있음을 의미하며 방어자는 항상 자동화된 대량 공격에 대비해야 합니다.

---

### 3. 원인 및 해결 방안

*   **원인: 데이터와 명령어의 경계 붕괴**

   모든 SQL Injection 공격의 진짜 원인은 사용자가 입력한 데이터와 개발자가 만든 명령어를 서버가 구분하지 못했기 때문입니다. 사용자가 입력한 값을 아무런 의심 없이 원래의 SQL 코드에 그대로 합쳐버리니 평범한 **`데이터`**여야 할 입력값이 악의적인 **`명령어`**로 변신해서 실행되어 버리는 것입니다.

*   **해결 방안: 매개변수화된 쿼리 Prepared Statement**

   이 문제를 해결하는 가장 확실하고 안전한 방법은 `Prepared Statement`를 사용하는 것입니다. 이 방식은 먼저 SQL 코드의 '틀'을 데이터베이스에 보내 컴파일하고 이후 사용자 입력값은 '데이터'로만 안전하게 전달합니다. 이렇게 명령어(틀)와 데이터(내용)를 완전히 분리해서 처리하기 때문에 공격자가 악성 코드를 주입하더라도 절대 명령어로 실행되지 않습니다. 이것이 SQL 인젝션 공격을 원천적으로 막는 가장 근본적인 해결책입니다.

---

### 4. 시큐어 코딩: 코드 레벨 분석

**분석 대상:** DVWA - SQL Injection

#### 취약한 코드 분석 Low Level

   ![]({{ "/assets/images/A03_S-1.png" | relative_url }})  

   *   **코드 분석:** 이 코드는 `$id = $_REQUEST['id'];` 를 통해 사용자 입력값을 아무런 검증 없이 변수에 할당한 뒤, SQL 쿼리문 내에서 `WHERE user_id = '$id'` 와 같이 문자열 합치기 방식으로 그대로 결합하고 있습니다. 이것이 바로 데이터와 명령어의 경계를 허물어 공격자의 입력`' or '1'='1'`이 서버의 SQL 명령어로 해석되게 만드는 직접적인 원인입니다.

#### 안전한 코드 분석 Impossible Level

   ![]({{ "/assets/images/A03_S-2.png" | relative_url }})  

   *   **코드 분석:** 안전한 코드는 **Prepared Statement**를 사용합니다. 먼저 `prepare('... WHERE user_id = (:id) ...')` 를 통해 사용자 입력이 들어갈 자리를 플레이스홀더`:id`로 지정하여 쿼리의 틀을 정의합니다. 그 후 `bindParam(':id', $id, PDO::PARAM_INT)` 함수를 통해 해당 자리에 변수 `$id`를 오직 정수형 데이터`PARAM_INT`로만 안전하게 전달합니다. 데이터베이스는 이 값을 절대 SQL 구문으로 해석하지 않으므로 인젝션 공격이 근본적으로 불가능합니다.

#### 핵심 방어 원리

   결론적으로 SQL 인젝션 방어의 핵심 원리는 `**'데이터와 코드의 분리'**` 입니다. 사용자 입력은 항상 데이터로만 취급하고 절대 신뢰해서는 안 되며 Prepared Statement는 이 원칙을 코드 레벨에서 구현하는 가장 표준적이고 강력한 방법입니다.

<hr class="short-rule">