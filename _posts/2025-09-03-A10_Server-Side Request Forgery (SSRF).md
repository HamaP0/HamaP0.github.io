---
layout: post
title: "A10:2021 - Server-Side Request Forgery (서버 측 요청 위조) 분석 보고서"
date: 2025-09-03 17:00:00 +0900
categories: Projects OWASP-Top-10
---
---

### **프로젝트 10.A10:2021 - Server-Side Request Forgery (SSRF) 분석 보고서**

#### **1. 취약점 개요**

**서버 측 요청 위조`SSRF`**는 공격자가 서버를 속여 원래는 접근하면 안 되는 서버의 내부망이나 자기 자신localhost에게 대신 요청을 보내도록 조종하는 공격입니다. 방화벽이라는 경비원이 외부인의 접근을 막고 있더라도 이미 내부에 있는 서버를 내부 스파이로 만들어 방화벽 너머의 민감한 정보를 훔쳐보게 만드는 것과 같습니다.

이 보고서는 최신 DVWA 환경에서 SSRF 공격을 시도하며 마주친 여러 방어 로직을 소스코드와 시스템 환경 분석을 통해 단계적으로 우회하고 최종적으로 공격을 성공시키는 현실적인 문제 해결 과정을 기록했습니다.

---

#### **2. 시나리오 분석 및 재현: 우회 전략의 수립과 증명**

**Part 1. 공격 벡터 탐색 및 1차 방어벽 확인**

*   **초기 접근:**
가장 먼저, 외부 URL 포함 기능이 예상되는 `File Inclusion` 모듈을 공격 벡터로 탐색했습니다. 하지만 해당 모듈은 서버의 PHP 설정`allow_url_include=Off` 단에서 기능이 원천적으로 비활성화되어 있어 공격 시도가 불가능했습니다. 이는 안전한 기본 설정`Secure by Default` 원칙에 따른 훌륭한 방어 사례였습니다.

*   **공격 벡터 전환:**
이에, 서버가 직접 쉘 명령어를 실행하는 `Command Injection` 모듈로 공격 벡터를 전환`Pivot`했습니다. 이 모듈이라면 서버가 직접 외부와 통신하는 명령을 내리게 할 수 있을 것이라 판단했습니다.

**Part 2. Low 레벨 소스코드 분석을 통한 우회 전략 수립**

*   **문제 봉착:**
`&&`나 `|`를 이용한 일반적인 명령어 체이닝`Chaining` 페이로드는 모두 실패했습니다. 이 원인을 파악하기 위해, `Security Level: Low`의 소스코드를 직접 분석했습니다.

   ![Low code](/assets/images/A10_P2-1.png)
    
분석 결과, 모든 입력값`$target`이 `ping -c 4` 라는 문자열 뒤에 붙어서 실행되는 구조임을 확인했습니다. 이 때문에 `&&`나 `|` 같은 연산자가 쉘에서 의도대로 해석되지 않는 것이 실패의 근본 원인이었습니다.

*   **우회 전략 수립:**
ping 명령어의 제약에서 벗어나기 위해, 앞선 명령어의 성공 여부와 관계없이 명령을 강제로 종료하고 새로운 명령을 시작하는 세미콜론`;` 구분자를 활용하는 전략을 수립했습니다. `127.0.0.1; whoami` 페이로드를 테스트한 결과, ping 실행 후 `www-data`가 성공적으로 출력되어 이 전략이 유효함을 증명했습니다.

   ![whoami](/assets/images/A10_P2-2.png)

**Part 3. 최종 공격 성공 및 결정적 증거 확보**

*   **최종 페이로드 구성:**
`whoami`의 성공 이후에도 `curl`을 이용한 시도는 여전히 실패했습니다. 이는 서버에 curl이 설치되지 않았을 가능성을 시사했습니다. `which wget` 페이로드를 통해 서버에 `wget`이 설치된 사실`_usr/bin/wget_`을 확인하고, 이를 활용한 최종 페이로드 `127.0.0.1; wget -qO- ifconfig.me` 를 구성했습니다.

   ![wget](/assets/images/A10_P3-1.png)

*   **공격 성공 및 증거 분석:**
최종 페이로드를 주입하자, 마침내 서버가 외부 서버`ifconfig.me`와 통신하고 받아온 응답이 화면에 출력되었습니다.

   ![ifconfig.me](/assets/images/A10_P3-2.png)
   ![interface](/assets/images/A10_P3-3.png)

이 공격의 성공은 두 가지 명백한 증거로 증명됩니다.
1.  **공인 IP 주소`61.108.60.26` 출력:** 서버가 외부 인터넷과 통신했음을 의미합니다.
2.  **사용자 에이전트`User Agent: Wget/1.21.4` 기록:** 이 요청이 제 브라우저 Firefox가 아닌, 서버 내부의 `wget` 프로그램을 통해 시작되었다는 결정적인 증거**Smoking Gun**입니다.

이 SSRF 취약점은 방화벽을 우회하여 내부망을 스캔하거나, 클라우드 환경의 메타데이터 서비스를 공격하여 인프라 전체의 권한을 탈취하는 등의 치명적인 위협으로 이어질 수 있습니다.

---

#### **3. 근본 원인 및 해결 방안: 신뢰의 경계 설정**

*   **원인: 신뢰 경계의 명확한 설정**

이번 공격의 근본 원인은 `Command Injection` 취약점이었지만, SSRF 관점의 핵심 원인은 '서버가 시작하는 아웃바운드 Outbound 요청의 목적지를 아무런 의심 없이 신뢰했다'는 것입니다. 서버는 공격자가 제공한 `ifconfig.me`라는 목적지가 안전한지 전혀 검증하지 않았습니다.

*   **해결 방안: 신뢰 경계의 명확한 설정**

SSRF에 대한 방어는 제로 트러스트`Zero Trust` 원칙에 입각하여 서버가 보내는 모든 외부 요청을 철저히 검증하는 것에서 시작합니다.

1.  **화이트리스트 기반 접근 제어 `Whitelist`:** 가장 강력한 방법은, 서버가 요청을 보낼 수 있는 도메인과 포트의 목록Whitelist을 미리 정해두고, 이 목록에 없는 요청은 모두 차단하는 것입니다.
2.  **입력값 검증 및 파싱:** 부득이하게 사용자가 URL을 입력해야 한다면 입력된 URL을 표준 라이브러리를 사용해 파싱하고 그 결과로 나온 IP 주소가 내부망 대역`10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`이나 로컬호스트`127.0.0.1`에 해당하는지 반드시 검사해야 합니다.
3.  **네트워크 격리:** 서버가 꼭 필요한 경우가 아니라면 외부 인터넷으로 나가는 아웃바운드Outbound 트래픽을 방화벽에서 기본적으로 차단해야 합니다. 특히, 클라우드 환경에서는 메타데이터 서비스 IP로의 접근을 애플리케이션 서버에서 원천적으로 차단하는 네트워크 정책`Security Group` 등을 적용해야 합니다.
    
결론적으로 서버는 신뢰할 수 있는 심부름꾼이어야 하지만 어디로 심부름을 가야 하는지는 우리가 명확하게 통제하고 알려주어야만 합니다.

<hr class="short-rule">